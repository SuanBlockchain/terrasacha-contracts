{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Terrasacha Contracts","text":"<p>Welcome to the Terrasacha Contracts documentation. This project implements Cardano smart contracts for carbon credit tokens and NFTs using OpShin.</p>"},{"location":"#overview","title":"Overview","text":"<p>A Cardano decentralized application (dApp) built with OpShin smart contracts and uv for fast dependency management. The project implements a protocol for managing carbon credit tokens and NFTs with advanced validation and minting capabilities.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Protocol Validator: Manages protocol state and NFT validation with linear progression patterns</li> <li>Minting Policies: Creates unique paired NFTs (protocol + user tokens) with UTXO-based uniqueness</li> <li>Linear Progression: Enforces one-input-to-one-output patterns to prevent state fragmentation</li> <li>Datum Immutability: Core protocol parameters cannot be changed after initialization</li> <li>Type Safety: Comprehensive type checking with mypy and strict validation</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Install uv\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Install dependencies\nuv sync --extra dev\n\n# Build all contracts\nuv run python src/scripts/build_contracts.py\n\n# Run tests\nuv run pytest\n</code></pre>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>terrasacha-contracts/\n\u251c\u2500\u2500 src/terrasacha_contracts/\n\u2502   \u251c\u2500\u2500 validators/           # OpShin validator contracts\n\u2502   \u251c\u2500\u2500 minting_policies/     # OpShin minting policies\n\u2502   \u251c\u2500\u2500 types.py             # Type definitions and datums\n\u2502   \u2514\u2500\u2500 util.py              # Helper functions\n\u251c\u2500\u2500 artifacts/\n\u2502   \u251c\u2500\u2500 validators/          # Compiled validator contracts\n\u2502   \u2514\u2500\u2500 minting_policies/    # Compiled minting policies\n\u251c\u2500\u2500 src/scripts/             # Build and utility scripts\n\u251c\u2500\u2500 tests/                   # Test files\n\u2514\u2500\u2500 pyproject.toml          # Project configuration\n</code></pre>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide - Set up your development environment</li> <li>Quick Start - Build and deploy your first contract</li> <li>Architecture Overview - Understand the system design</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"#technology-stack","title":"Technology Stack","text":"<ul> <li>OpShin 0.26.x - Python-based smart contract language for Cardano</li> <li>uv - Fast Python package manager</li> <li>pytest - Testing framework with comprehensive coverage</li> <li>ruff - Fast Python linter and formatter</li> <li>mypy - Static type checker</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>Built with OpShin 0.26.x targeting the Cardano blockchain. Currently in active development.</p>"},{"location":"#support","title":"Support","text":"<ul> <li>GitHub Repository</li> <li>OpShin Documentation</li> <li>Cardano Developer Portal</li> </ul>"},{"location":"api/minting-policies/","title":"Minting Policies API Reference","text":"<p>API reference documentation for minting policy contracts.</p>"},{"location":"api/minting-policies/#coming-soon","title":"Coming Soon","text":"<p>Detailed API documentation for: - Protocol NFT minting policy - Helper functions - Type signatures - Usage examples</p> <p>For now, see: - Minting Policies Architecture - Source Code</p>"},{"location":"api/types/","title":"Types API Reference","text":"<p>API reference documentation for type definitions.</p>"},{"location":"api/types/#coming-soon","title":"Coming Soon","text":"<p>Detailed API documentation for: - DatumProtocol - Redeemer types - Type aliases - Constants</p> <p>For now, see: - Types &amp; Datums - Source Code</p>"},{"location":"api/utilities/","title":"Utilities API Reference","text":"<p>API reference documentation for utility functions.</p>"},{"location":"api/utilities/#coming-soon","title":"Coming Soon","text":"<p>Detailed API documentation for: - Linear validation helpers - Token name generation - UTXO helpers - Serialization utilities</p> <p>For now, see: - Source Code</p>"},{"location":"api/validators/","title":"Validators API Reference","text":"<p>API reference documentation for validator contracts.</p>"},{"location":"api/validators/#coming-soon","title":"Coming Soon","text":"<p>Detailed API documentation for: - Protocol validator - Helper functions - Type signatures - Usage examples</p> <p>For now, see: - Validators Architecture - Source Code</p>"},{"location":"architecture/minting-policies/","title":"Minting Policies","text":"<p>Minting policies control the creation and destruction of tokens in Terrasacha Contracts.</p>"},{"location":"architecture/minting-policies/#overview","title":"Overview","text":"<p>Minting policies in Cardano determine: - When tokens can be minted (created) - When tokens can be burned (destroyed) - Token naming rules - Quantity restrictions</p>"},{"location":"architecture/minting-policies/#protocol-nfts-minting-policy","title":"Protocol NFTs Minting Policy","text":"<p>The main minting policy for protocol and user token pairs.</p>"},{"location":"architecture/minting-policies/#location","title":"Location","text":"<p><code>src/terrasacha_contracts/minting_policies/protocol_nfts.py</code></p>"},{"location":"architecture/minting-policies/#purpose","title":"Purpose","text":"<ul> <li>Mints paired NFTs (protocol + user tokens)</li> <li>Enforces exactly 2 tokens per mint operation</li> <li>Uses UTXO reference for global uniqueness</li> <li>Handles both minting and burning operations</li> </ul>"},{"location":"architecture/minting-policies/#token-prefixes","title":"Token Prefixes","text":"<pre><code>PROTO_PREFIX = b\"PROTO_\"  # Protocol NFT (goes to validator)\nUSER_PREFIX = b\"USER_\"     # User NFT (goes to user wallet)\n</code></pre>"},{"location":"architecture/minting-policies/#redeemers","title":"Redeemers","text":"<pre><code>class Mint:\n    \"\"\"Create new token pair\"\"\"\n    pass\n\nclass Burn:\n    \"\"\"Destroy existing token pair\"\"\"\n    pass\n</code></pre>"},{"location":"architecture/minting-policies/#minting-flow","title":"Minting Flow","text":""},{"location":"architecture/minting-policies/#1-utxo-based-uniqueness","title":"1. UTXO-Based Uniqueness","text":"<p>Token names derive from a consumed UTXO:</p> <pre><code># Extract UTXO reference from transaction inputs\nutxo_ref = find_consumed_utxo(context.tx_info.inputs)\n\n# Generate unique suffix from UTXO\nunique_suffix = hash_utxo(utxo_ref.tx_id, utxo_ref.output_index)\n\n# Create token names\nprotocol_token = PROTO_PREFIX + unique_suffix\nuser_token = USER_PREFIX + unique_suffix\n</code></pre> <p>This guarantees: - Global uniqueness: Each UTXO can only be consumed once - Deterministic naming: Same UTXO always produces same token names - No collisions: Impossible to create duplicate token names</p>"},{"location":"architecture/minting-policies/#2-paired-minting-validation","title":"2. Paired Minting Validation","text":"<p>Exactly 2 tokens must be minted:</p> <pre><code>minted_tokens = get_minted_tokens(context.tx_info.mint, own_policy)\n\nassert len(minted_tokens) == 2, \"Must mint exactly 2 tokens\"\n\n# Verify one protocol token\nprotocol_tokens = [t for t in minted_tokens if t.startswith(PROTO_PREFIX)]\nassert len(protocol_tokens) == 1, \"Must mint exactly 1 protocol token\"\n\n# Verify one user token\nuser_tokens = [t for t in minted_tokens if t.startswith(USER_PREFIX)]\nassert len(user_tokens) == 1, \"Must mint exactly 1 user token\"\n\n# Verify matching suffixes\nassert protocol_tokens[0][len(PROTO_PREFIX):] == user_tokens[0][len(USER_PREFIX):], \\\n    \"Token suffixes must match\"\n</code></pre>"},{"location":"architecture/minting-policies/#3-distribution-validation","title":"3. Distribution Validation","text":"<p>Tokens must go to correct destinations:</p> <pre><code># Protocol token must go to protocol validator\nprotocol_output = find_output_with_token(\n    context.tx_info.outputs,\n    protocol_token,\n    protocol_validator_address\n)\nassert protocol_output is not None, \"Protocol token must go to validator\"\n\n# User token goes to user (any address except validator)\nuser_output = find_output_with_token(\n    context.tx_info.outputs,\n    user_token\n)\nassert user_output is not None, \"User token must be in outputs\"\nassert user_output.address != protocol_validator_address, \\\n    \"User token cannot go to validator\"\n</code></pre>"},{"location":"architecture/minting-policies/#complete-mint-example","title":"Complete Mint Example","text":"<pre><code>Transaction:\n  Inputs:\n    - UTXO: tx#123...abc, index 0  \u2190 Consumed for uniqueness\n    - User's ADA for fees\n\n  Mint:\n    - 1x PROTO_abc123...def (protocol NFT)\n    - 1x USER_abc123...def (user NFT)\n\n  Outputs:\n    - To protocol validator:\n        \u2022 2 ADA\n        \u2022 1x PROTO_abc123...def\n        \u2022 Datum: DatumProtocol(...)\n\n    - To user wallet:\n        \u2022 1x USER_abc123...def\n        \u2022 Change ADA\n</code></pre>"},{"location":"architecture/minting-policies/#burning-flow","title":"Burning Flow","text":""},{"location":"architecture/minting-policies/#1-burn-validation","title":"1. Burn Validation","text":"<p>Tokens must be burned (negative quantities):</p> <pre><code>burned_tokens = get_burned_tokens(context.tx_info.mint, own_policy)\n\n# Both tokens must be burned together\nassert len(burned_tokens) == 2, \"Must burn exactly 2 tokens\"\n\n# Verify one protocol token burned\nprotocol_burns = [t for t in burned_tokens if t.startswith(PROTO_PREFIX)]\nassert len(protocol_burns) == 1, \"Must burn exactly 1 protocol token\"\n\n# Verify one user token burned\nuser_burns = [t for t in burned_tokens if t.startswith(USER_PREFIX)]\nassert len(user_burns) == 1, \"Must burn exactly 1 user token\"\n\n# Verify matching suffixes\nassert protocol_burns[0][len(PROTO_PREFIX):] == user_burns[0][len(USER_PREFIX):], \\\n    \"Burned token suffixes must match\"\n</code></pre>"},{"location":"architecture/minting-policies/#2-authorization-check","title":"2. Authorization Check","text":"<p>Only authorized parties can burn:</p> <pre><code># Typically requires signature from admin or token holder\nauthorized = check_burn_authorization(context.tx_info.signatories)\nassert authorized, \"Unauthorized burn attempt\"\n</code></pre>"},{"location":"architecture/minting-policies/#complete-burn-example","title":"Complete Burn Example","text":"<pre><code>Transaction:\n  Inputs:\n    - From protocol validator:\n        \u2022 2 ADA\n        \u2022 1x PROTO_abc123...def\n\n    - From user wallet:\n        \u2022 1x USER_abc123...def\n\n  Mint (negative = burn):\n    - -1x PROTO_abc123...def\n    - -1x USER_abc123...def\n\n  Outputs:\n    - To user wallet:\n        \u2022 Reclaimed ADA\n</code></pre>"},{"location":"architecture/minting-policies/#token-naming-convention","title":"Token Naming Convention","text":""},{"location":"architecture/minting-policies/#format","title":"Format","text":"<pre><code>&lt;PREFIX&gt;_&lt;UNIQUE_SUFFIX&gt;\n\nWhere:\n  PREFIX = \"PROTO\" or \"USER\"\n  UNIQUE_SUFFIX = sha256(tx_id || output_index)\n</code></pre>"},{"location":"architecture/minting-policies/#example","title":"Example","text":"<pre><code>Input UTXO:\n  tx_id = 0x123abc...\n  output_index = 0\n\nHash = sha256(\"0x123abc...\" + \"0\")\n     = 0xdef456...\n\nTokens:\n  Protocol: PROTO_def456...\n  User:     USER_def456...\n</code></pre>"},{"location":"architecture/minting-policies/#benefits","title":"Benefits","text":"<ul> <li>Uniqueness: UTXO consumption ensures one-time use</li> <li>Verifiable: Anyone can verify token authenticity</li> <li>Deterministic: Same input always produces same output</li> <li>Collision-resistant: SHA256 prevents collisions</li> </ul>"},{"location":"architecture/minting-policies/#helper-functions","title":"Helper Functions","text":""},{"location":"architecture/minting-policies/#hash_utxo","title":"hash_utxo","text":"<p>Generates unique hash from UTXO reference:</p> <pre><code>def hash_utxo(tx_id: bytes, output_index: int) -&gt; bytes:\n    \"\"\"\n    Create unique hash from UTXO components.\n    Returns first 28 bytes of SHA256 hash.\n    \"\"\"\n    data = tx_id + output_index.to_bytes(8, 'big')\n    return sha256(data)[:28]  # Cardano token name limit\n</code></pre>"},{"location":"architecture/minting-policies/#find_consumed_utxo","title":"find_consumed_utxo","text":"<p>Extracts specific UTXO from inputs:</p> <pre><code>def find_consumed_utxo(\n    inputs: List[TxInInfo],\n    tx_id: bytes,\n    index: int\n) -&gt; TxInInfo:\n    \"\"\"\n    Find input with specific UTXO reference.\n    Used to verify correct UTXO consumed for minting.\n    \"\"\"\n</code></pre>"},{"location":"architecture/minting-policies/#error-cases","title":"Error Cases","text":""},{"location":"architecture/minting-policies/#wrong-token-count","title":"Wrong Token Count","text":"<pre><code>Error: \"Must mint exactly 2 tokens\"\nCause: Attempting to mint 1, 3, or more tokens\nFix: Always mint exactly 1 protocol + 1 user token\n</code></pre>"},{"location":"architecture/minting-policies/#mismatched-suffixes","title":"Mismatched Suffixes","text":"<pre><code>Error: \"Token suffixes must match\"\nCause: Protocol and user tokens have different suffixes\nFix: Generate both from same UTXO hash\n</code></pre>"},{"location":"architecture/minting-policies/#wrong-distribution","title":"Wrong Distribution","text":"<pre><code>Error: \"Protocol token must go to validator\"\nCause: Protocol token sent to wrong address\nFix: Send protocol token to validator address\n</code></pre>"},{"location":"architecture/minting-policies/#utxo-not-found","title":"UTXO Not Found","text":"<pre><code>Error: \"Required UTXO not consumed\"\nCause: Specified UTXO not in transaction inputs\nFix: Include correct UTXO in inputs\n</code></pre>"},{"location":"architecture/minting-policies/#best-practices","title":"Best Practices","text":""},{"location":"architecture/minting-policies/#when-minting","title":"When Minting","text":"<ol> <li>Choose a UTXO to consume for uniqueness</li> <li>Generate token names from UTXO hash</li> <li>Mint exactly 2 tokens (1 protocol, 1 user)</li> <li>Send protocol token to validator with datum</li> <li>Send user token to user wallet</li> </ol>"},{"location":"architecture/minting-policies/#when-burning","title":"When Burning","text":"<ol> <li>Include both tokens in burn</li> <li>Provide proper authorization</li> <li>Reclaim locked ADA from validator</li> <li>Clean up protocol state</li> </ol>"},{"location":"architecture/minting-policies/#testing-minting-policies","title":"Testing Minting Policies","text":"<pre><code>def test_protocol_nft_mint():\n    # Setup\n    utxo_ref = mock_utxo_reference()\n    redeemer = Mint()\n    context = mock_mint_context(utxo_ref, 2)\n\n    # Execute\n    result = protocol_nfts_policy(redeemer, context)\n\n    # Assert\n    assert result is True\n</code></pre>"},{"location":"architecture/minting-policies/#see-also","title":"See Also","text":"<ul> <li>Validators - Protocol state validation</li> <li>Types - Datum and redeemer definitions</li> <li>API Reference - Full API documentation</li> </ul>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>Terrasacha Contracts implements a modular smart contract system for carbon credit tokens and NFTs on the Cardano blockchain.</p>"},{"location":"architecture/overview/#system-design","title":"System Design","text":"<p>The architecture follows a modular design with clear separation of concerns:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Protocol System                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502   Validators    \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Minting Policies \u2502       \u2502\n\u2502  \u2502                 \u2502         \u2502                 \u2502       \u2502\n\u2502  \u2502  - protocol.py  \u2502         \u2502 - protocol_nfts \u2502       \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502           \u2502                           \u2502                 \u2502\n\u2502           \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502                 \u2502\n\u2502           \u2514\u2500\u2500\u2500\u2500\u2524    Types     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\n\u2502                \u2502              \u2502                          \u2502\n\u2502                \u2502 - DatumProto \u2502                          \u2502\n\u2502                \u2502 - Redeemers  \u2502                          \u2502\n\u2502                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2502\n\u2502                       \u2502                                  \u2502\n\u2502                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                          \u2502\n\u2502                \u2502  Utilities   \u2502                          \u2502\n\u2502                \u2502              \u2502                          \u2502\n\u2502                \u2502 - Linear     \u2502                          \u2502\n\u2502                \u2502 - UTXO       \u2502                          \u2502\n\u2502                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/overview/#core-components","title":"Core Components","text":""},{"location":"architecture/overview/#1-validators","title":"1. Validators","text":"<p>Validators enforce business logic and state transitions.</p> <p>Protocol Validator (<code>protocol.py</code>): - Validates protocol NFT continuation across transactions - Handles protocol updates with authorization checks - Implements linear progression (one input \u2192 one output) - Prevents state fragmentation</p> <p>See: Validators Documentation</p>"},{"location":"architecture/overview/#2-minting-policies","title":"2. Minting Policies","text":"<p>Minting policies control token creation and burning.</p> <p>Protocol NFTs (<code>protocol_nfts.py</code>): - Mints paired NFTs (protocol + user tokens) - Enforces exactly 2 tokens per mint - Uses UTXO reference for uniqueness - Handles burning operations</p> <p>See: Minting Policies Documentation</p>"},{"location":"architecture/overview/#3-types-and-datums","title":"3. Types and Datums","text":"<p>Type definitions ensure type safety and correctness.</p> <p>DatumProtocol: <pre><code>class DatumProtocol:\n    admin: List[PubKeyHash]    # Admin public key hashes\n    fees: int                  # Protocol fees\n    oracle_id: bytes           # Oracle identifier\n    project_id: bytes          # Project identifier\n</code></pre></p> <p>See: Types &amp; Datums Documentation</p>"},{"location":"architecture/overview/#4-utilities","title":"4. Utilities","text":"<p>Helper functions for common operations.</p> <ul> <li>Linear validation: <code>resolve_linear_input</code>, <code>resolve_linear_output</code></li> <li>Token naming: UTXO-based unique name generation</li> <li>UTXO helpers: Purpose extraction and validation</li> </ul>"},{"location":"architecture/overview/#key-design-patterns","title":"Key Design Patterns","text":""},{"location":"architecture/overview/#linear-progression","title":"Linear Progression","text":"<p>Contracts enforce one-input-to-one-output patterns:</p> <pre><code>Input UTXO \u2500\u2500\u2500\u2500\u2500\u2500\u25ba Validator \u2500\u2500\u2500\u2500\u2500\u2500\u25ba Output UTXO\n  (with NFT)                          (with same NFT)\n</code></pre> <p>Benefits: - Prevents state fragmentation - Ensures state continuity - Simplifies validation logic - Reduces complexity</p>"},{"location":"architecture/overview/#paired-token-system","title":"Paired Token System","text":"<p>Protocol and user NFTs are minted together:</p> <pre><code>Mint Transaction\n\u251c\u2500\u2500 Token 1: PROTO_&lt;unique_suffix&gt;  (to protocol validator)\n\u2514\u2500\u2500 Token 2: USER_&lt;unique_suffix&gt;   (to user wallet)\n</code></pre> <p>Benefits: - Shared uniqueness guarantee - Simplified tracking - Clear ownership model</p>"},{"location":"architecture/overview/#utxo-based-uniqueness","title":"UTXO-Based Uniqueness","text":"<p>Token names derive from consuming specific UTXOs:</p> <pre><code>unique_suffix = sha256(txid + output_index)\nprotocol_token = \"PROTO_\" + unique_suffix\nuser_token = \"USER_\" + unique_suffix\n</code></pre> <p>Benefits: - Guaranteed global uniqueness - No need for centralized registry - Verifiable on-chain</p>"},{"location":"architecture/overview/#datum-immutability","title":"Datum Immutability","text":"<p>Core protocol parameters cannot change:</p> <pre><code># \u2705 Can update\nnew_datum.fees = updated_fees\n\n# \u274c Cannot change\nnew_datum.admin = ...        # Must stay same\nnew_datum.oracle_id = ...    # Must stay same\nnew_datum.project_id = ...   # Must stay same\n</code></pre> <p>Benefits: - Predictable behavior - Trust preservation - Security guarantee</p>"},{"location":"architecture/overview/#transaction-flow","title":"Transaction Flow","text":""},{"location":"architecture/overview/#minting-flow","title":"Minting Flow","text":"<ol> <li>User initiates mint transaction</li> <li>Minting policy validates:</li> <li>Exactly 2 tokens minted</li> <li>Token names follow convention</li> <li>UTXO consumed for uniqueness</li> <li>Tokens distributed:</li> <li>Protocol token \u2192 validator script</li> <li>User token \u2192 user wallet</li> <li>Protocol datum initialized</li> </ol>"},{"location":"architecture/overview/#update-flow","title":"Update Flow","text":"<ol> <li>User submits update transaction</li> <li>Validator verifies:</li> <li>Correct redeemer (UpdateProtocol)</li> <li>Admin signature present</li> <li>Linear progression maintained</li> <li>Immutable fields unchanged</li> <li>New datum created with updates</li> <li>Protocol NFT continues to output</li> </ol>"},{"location":"architecture/overview/#burning-flow","title":"Burning Flow","text":"<ol> <li>User initiates burn transaction</li> <li>Minting policy validates:</li> <li>Correct burn redeemer</li> <li>Proper authorization</li> <li>Tokens destroyed</li> <li>Protocol state cleaned up</li> </ol>"},{"location":"architecture/overview/#security-model","title":"Security Model","text":""},{"location":"architecture/overview/#authorization","title":"Authorization","text":"<ul> <li>Admin keys control protocol updates</li> <li>Multi-signature support for admin actions</li> <li>User keys control user tokens</li> </ul>"},{"location":"architecture/overview/#validation-layers","title":"Validation Layers","text":"<ol> <li>Type safety: OpShin type checking</li> <li>On-chain validation: Plutus validators</li> <li>Off-chain validation: Client-side checks</li> <li>Test coverage: Comprehensive test suite</li> </ol>"},{"location":"architecture/overview/#attack-mitigation","title":"Attack Mitigation","text":"<ul> <li>Double spending: UTXO model prevents</li> <li>State fragmentation: Linear progression prevents</li> <li>Unauthorized updates: Admin key checks prevent</li> <li>Token duplication: Minting policy prevents</li> </ul>"},{"location":"architecture/overview/#build-system","title":"Build System","text":"<p>Contracts compile to two formats:</p> <ul> <li><code>.plutus</code>: JSON format for inspection/debugging</li> <li><code>.cbor</code>: Binary format for on-chain deployment</li> </ul> <p>Build pipeline: <pre><code>OpShin Source (.py)\n    \u2502\n    \u251c\u2500\u2500\u25ba Compiler\n    \u2502\n    \u251c\u2500\u2500\u25ba .plutus (JSON)\n    \u2502\n    \u2514\u2500\u2500\u25ba .cbor (Binary)\n</code></pre></p>"},{"location":"architecture/overview/#testing-strategy","title":"Testing Strategy","text":"<p>Multi-layered testing approach:</p> <ol> <li>Unit tests: Test individual functions</li> <li>Integration tests: Test component interactions</li> <li>Contract tests: Test compiled contracts</li> <li>Property tests: Hypothesis-based testing</li> </ol> <p>See: Testing Documentation</p>"},{"location":"architecture/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Validators - Deep dive into validator logic</li> <li>Minting Policies - Understand token minting</li> <li>Types - Explore type definitions</li> <li>API Reference - Full API documentation</li> </ul>"},{"location":"architecture/types/","title":"Types &amp; Datums","text":"<p>Type definitions and data structures used throughout Terrasacha Contracts.</p>"},{"location":"architecture/types/#overview","title":"Overview","text":"<p>The type system ensures: - Type safety: Compile-time checking with mypy - On-chain correctness: Proper serialization to Plutus data - Clear contracts: Self-documenting code</p>"},{"location":"architecture/types/#location","title":"Location","text":"<p><code>src/terrasacha_contracts/types.py</code></p>"},{"location":"architecture/types/#core-types","title":"Core Types","text":""},{"location":"architecture/types/#datumprotocol","title":"DatumProtocol","text":"<p>The main datum type attached to protocol UTXOs.</p> <pre><code>@dataclass\nclass DatumProtocol:\n    \"\"\"\n    Protocol state stored on-chain.\n    Attached to UTXOs locked at protocol validator.\n    \"\"\"\n    admin: List[PubKeyHash]  # Admin public key hashes (multi-sig support)\n    fees: int                # Protocol fee amount in lovelace\n    oracle_id: bytes         # Oracle identifier (immutable)\n    project_id: bytes        # Project identifier (immutable)\n</code></pre>"},{"location":"architecture/types/#fields","title":"Fields","text":"<p>admin (<code>List[PubKeyHash]</code>) - Public key hashes authorized to update protocol - Supports multi-signature (any admin can authorize) - Immutable: Cannot be changed after initialization</p> <p>fees (<code>int</code>) - Protocol fee in lovelace (1 ADA = 1,000,000 lovelace) - Mutable: Can be updated via UpdateProtocol redeemer - Example: <code>2_000_000</code> = 2 ADA fee</p> <p>oracle_id (<code>bytes</code>) - Identifies the oracle providing data feeds - Immutable: Cannot be changed after initialization - Typically a hash or identifier</p> <p>project_id (<code>bytes</code>) - Identifies the carbon credit project - Immutable: Cannot be changed after initialization - Links protocol to specific project</p>"},{"location":"architecture/types/#usage","title":"Usage","text":"<pre><code># Create initial datum\ndatum = DatumProtocol(\n    admin=[PubKeyHash(b\"admin_key_hash_1\"), PubKeyHash(b\"admin_key_hash_2\")],\n    fees=2_000_000,  # 2 ADA\n    oracle_id=b\"oracle_xyz\",\n    project_id=b\"project_abc\"\n)\n\n# Update mutable fields\nnew_datum = DatumProtocol(\n    admin=datum.admin,         # Must stay same\n    fees=5_000_000,            # Can update (5 ADA)\n    oracle_id=datum.oracle_id, # Must stay same\n    project_id=datum.project_id # Must stay same\n)\n</code></pre>"},{"location":"architecture/types/#redeemer-types","title":"Redeemer Types","text":""},{"location":"architecture/types/#validator-redeemers","title":"Validator Redeemers","text":"<p>Used with protocol validator to specify actions.</p>"},{"location":"architecture/types/#updateprotocol","title":"UpdateProtocol","text":"<pre><code>@dataclass\nclass UpdateProtocol:\n    \"\"\"\n    Redeemer to update protocol parameters.\n    Requires admin signature.\n    \"\"\"\n    pass  # No additional data needed\n</code></pre> <p>Usage: <pre><code>redeemer = UpdateProtocol()\n</code></pre></p> <p>Requirements: - Admin signature in transaction - Linear progression (1 input \u2192 1 output) - Immutable fields unchanged</p>"},{"location":"architecture/types/#endprotocol","title":"EndProtocol","text":"<pre><code>@dataclass\nclass EndProtocol:\n    \"\"\"\n    Redeemer to terminate protocol.\n    Burns protocol NFT.\n    Requires admin signature.\n    \"\"\"\n    pass  # No additional data needed\n</code></pre> <p>Usage: <pre><code>redeemer = EndProtocol()\n</code></pre></p> <p>Requirements: - Admin signature in transaction - Protocol NFT burned (not in outputs)</p>"},{"location":"architecture/types/#minting-policy-redeemers","title":"Minting Policy Redeemers","text":"<p>Used with minting policies to control token operations.</p>"},{"location":"architecture/types/#mint","title":"Mint","text":"<pre><code>@dataclass\nclass Mint:\n    \"\"\"\n    Redeemer to mint new token pair.\n    Creates protocol + user NFTs.\n    \"\"\"\n    pass  # No additional data needed\n</code></pre> <p>Usage: <pre><code>redeemer = Mint()\n</code></pre></p> <p>Requirements: - UTXO consumed for uniqueness - Exactly 2 tokens minted - Correct token naming - Proper distribution</p>"},{"location":"architecture/types/#burn","title":"Burn","text":"<pre><code>@dataclass\nclass Burn:\n    \"\"\"\n    Redeemer to burn token pair.\n    Destroys protocol + user NFTs.\n    \"\"\"\n    pass  # No additional data needed\n</code></pre> <p>Usage: <pre><code>redeemer = Burn()\n</code></pre></p> <p>Requirements: - Both tokens burned together - Proper authorization - Matching token suffixes</p>"},{"location":"architecture/types/#type-aliases","title":"Type Aliases","text":""},{"location":"architecture/types/#pubkeyhash","title":"PubKeyHash","text":"<pre><code>PubKeyHash = bytes  # 28-byte hash of public key\n</code></pre> <p>Usage: <pre><code>admin_key = PubKeyHash(b\"\\\\x12\\\\x34...\\\\xab\\\\xcd\")  # 28 bytes\n</code></pre></p>"},{"location":"architecture/types/#policyid","title":"PolicyId","text":"<pre><code>PolicyId = bytes  # 28-byte minting policy hash\n</code></pre> <p>Usage: <pre><code>policy = PolicyId(b\"\\\\xab\\\\xcd...\\\\x12\\\\x34\")  # 28 bytes\n</code></pre></p>"},{"location":"architecture/types/#tokenname","title":"TokenName","text":"<pre><code>TokenName = bytes  # Token name (max 32 bytes)\n</code></pre> <p>Usage: <pre><code>token = TokenName(b\"PROTO_abc123def456\")\n</code></pre></p>"},{"location":"architecture/types/#constants","title":"Constants","text":""},{"location":"architecture/types/#token-prefixes","title":"Token Prefixes","text":"<pre><code>PROTO_PREFIX = b\"PROTO_\"  # Protocol NFT identifier\nUSER_PREFIX = b\"USER_\"     # User NFT identifier\n</code></pre> <p>Usage: <pre><code># Generate token names\nsuffix = generate_unique_suffix(utxo_ref)\nprotocol_token = PROTO_PREFIX + suffix\nuser_token = USER_PREFIX + suffix\n</code></pre></p>"},{"location":"architecture/types/#serialization","title":"Serialization","text":""},{"location":"architecture/types/#to-plutus-data","title":"To Plutus Data","text":"<p>Types automatically serialize to Plutus data format:</p> <pre><code>datum = DatumProtocol(...)\n\n# Serialization happens automatically when used in contracts\n# OpShin handles conversion to Plutus data\n</code></pre>"},{"location":"architecture/types/#from-plutus-data","title":"From Plutus Data","text":"<p>Deserialization from on-chain data:</p> <pre><code># In validator\ndef validator(datum: DatumProtocol, redeemer: UpdateProtocol, context: ScriptContext):\n    # datum automatically deserialized from Plutus data\n    admin_keys = datum.admin\n    ...\n</code></pre>"},{"location":"architecture/types/#type-validation","title":"Type Validation","text":""},{"location":"architecture/types/#compile-time-checks","title":"Compile-Time Checks","text":"<p>OpShin provides type checking during compilation:</p> <pre><code># \u2705 Valid\ndatum = DatumProtocol(\n    admin=[PubKeyHash(b\"key1\")],\n    fees=1_000_000,\n    oracle_id=b\"oracle\",\n    project_id=b\"project\"\n)\n\n# \u274c Invalid - type error\ndatum = DatumProtocol(\n    admin=\"not a list\",  # Wrong type\n    fees=\"not an int\",   # Wrong type\n    ...\n)\n</code></pre>"},{"location":"architecture/types/#runtime-checks","title":"Runtime Checks","text":"<p>Validators perform runtime validation:</p> <pre><code># Check immutable fields\nassert new_datum.admin == old_datum.admin, \"Admin cannot change\"\nassert new_datum.oracle_id == old_datum.oracle_id, \"Oracle ID immutable\"\nassert new_datum.project_id == old_datum.project_id, \"Project ID immutable\"\n\n# Validate fee range\nassert new_datum.fees &gt;= 0, \"Fees cannot be negative\"\nassert new_datum.fees &lt;= MAX_FEE, \"Fees exceed maximum\"\n</code></pre>"},{"location":"architecture/types/#best-practices","title":"Best Practices","text":""},{"location":"architecture/types/#datum-creation","title":"Datum Creation","text":"<pre><code># \u2705 Good: Clear, explicit values\ndatum = DatumProtocol(\n    admin=[admin_key_1, admin_key_2],\n    fees=2_000_000,\n    oracle_id=oracle_hash,\n    project_id=project_hash\n)\n\n# \u274c Bad: Magic numbers, unclear values\ndatum = DatumProtocol(\n    admin=[b\"\\\\x12\\\\x34...\"],\n    fees=2000000,  # What unit?\n    oracle_id=b\"xyz\",\n    project_id=b\"abc\"\n)\n</code></pre>"},{"location":"architecture/types/#type-hints","title":"Type Hints","text":"<pre><code># \u2705 Good: Explicit type hints\ndef create_protocol_datum(\n    admin_keys: List[PubKeyHash],\n    fee_amount: int,\n    oracle: bytes,\n    project: bytes\n) -&gt; DatumProtocol:\n    return DatumProtocol(\n        admin=admin_keys,\n        fees=fee_amount,\n        oracle_id=oracle,\n        project_id=project\n    )\n</code></pre>"},{"location":"architecture/types/#validation","title":"Validation","text":"<pre><code># \u2705 Good: Validate inputs\ndef validate_datum(datum: DatumProtocol) -&gt; bool:\n    # Check required fields\n    assert len(datum.admin) &gt; 0, \"At least one admin required\"\n    assert datum.fees &gt;= 0, \"Fees must be non-negative\"\n    assert len(datum.oracle_id) &gt; 0, \"Oracle ID required\"\n    assert len(datum.project_id) &gt; 0, \"Project ID required\"\n    return True\n</code></pre>"},{"location":"architecture/types/#testing-types","title":"Testing Types","text":"<pre><code>def test_datum_creation():\n    \"\"\"Test DatumProtocol creation\"\"\"\n    admin = [PubKeyHash(b\"admin_key\")]\n    datum = DatumProtocol(\n        admin=admin,\n        fees=1_000_000,\n        oracle_id=b\"oracle\",\n        project_id=b\"project\"\n    )\n\n    assert datum.admin == admin\n    assert datum.fees == 1_000_000\n    assert datum.oracle_id == b\"oracle\"\n    assert datum.project_id == b\"project\"\n\n\ndef test_datum_immutability():\n    \"\"\"Test immutable fields cannot change\"\"\"\n    old_datum = DatumProtocol(...)\n    new_datum = DatumProtocol(\n        admin=old_datum.admin,  # Keep same\n        fees=5_000_000,         # Can change\n        oracle_id=old_datum.oracle_id,  # Keep same\n        project_id=old_datum.project_id  # Keep same\n    )\n\n    # Validate immutability\n    assert new_datum.admin == old_datum.admin\n    assert new_datum.oracle_id == old_datum.oracle_id\n    assert new_datum.project_id == old_datum.project_id\n</code></pre>"},{"location":"architecture/types/#see-also","title":"See Also","text":"<ul> <li>Validators - Using datums in validators</li> <li>Minting Policies - Using redeemers</li> <li>API Reference - Full type documentation</li> </ul>"},{"location":"architecture/validators/","title":"Validators","text":"<p>Validators are the core logic components that enforce business rules and state transitions in Terrasacha Contracts.</p>"},{"location":"architecture/validators/#overview","title":"Overview","text":"<p>Validators in Cardano smart contracts determine whether a UTXO can be spent. They receive three inputs:</p> <ol> <li>Datum: State data attached to the UTXO</li> <li>Redeemer: Action/intent from the spender</li> <li>ScriptContext: Transaction context and environment</li> </ol>"},{"location":"architecture/validators/#protocol-validator","title":"Protocol Validator","text":"<p>The main validator managing protocol state and NFT validation.</p>"},{"location":"architecture/validators/#location","title":"Location","text":"<p><code>src/terrasacha_contracts/validators/protocol.py</code></p>"},{"location":"architecture/validators/#purpose","title":"Purpose","text":"<ul> <li>Validates protocol NFT continuation across transactions</li> <li>Handles protocol updates with proper authorization</li> <li>Implements linear progression patterns (one input \u2192 one output)</li> <li>Prevents state fragmentation and unauthorized modifications</li> </ul>"},{"location":"architecture/validators/#redeemers","title":"Redeemers","text":"<pre><code>class UpdateProtocol:\n    \"\"\"Update protocol parameters (authorized)\"\"\"\n    pass\n\nclass EndProtocol:\n    \"\"\"Terminate protocol and burn NFT\"\"\"\n    pass\n</code></pre>"},{"location":"architecture/validators/#validation-logic","title":"Validation Logic","text":""},{"location":"architecture/validators/#linear-progression-check","title":"Linear Progression Check","text":"<p>Ensures one input with protocol NFT \u2192 one output with same NFT:</p> <pre><code># Resolve the single input containing protocol NFT\nown_input = resolve_linear_input(context.tx_info.inputs, own_policy)\n\n# Resolve the single output continuing protocol NFT\nown_output = resolve_linear_output(\n    context.tx_info.outputs,\n    own_address,\n    own_policy\n)\n</code></pre> <p>Benefits: - Prevents splitting protocol state into multiple UTXOs - Ensures clear state continuity - Simplifies validation logic</p>"},{"location":"architecture/validators/#authorization-check","title":"Authorization Check","text":"<p>Verifies admin signatures for updates:</p> <pre><code># Extract admin keys from datum\nadmin_keys = datum.admin\n\n# Check that transaction is signed by at least one admin\nauthorized = any(\n    admin in context.tx_info.signatories\n    for admin in admin_keys\n)\n\nassert authorized, \"Unauthorized: missing admin signature\"\n</code></pre>"},{"location":"architecture/validators/#datum-immutability-check","title":"Datum Immutability Check","text":"<p>Ensures core fields cannot change:</p> <pre><code>new_datum = resolve_datum_from_output(own_output)\n\n# These fields must remain constant\nassert new_datum.admin == datum.admin, \"Admin cannot be changed\"\nassert new_datum.oracle_id == datum.oracle_id, \"Oracle ID is immutable\"\nassert new_datum.project_id == datum.project_id, \"Project ID is immutable\"\n\n# Fees can be updated\n# new_datum.fees can differ from datum.fees\n</code></pre>"},{"location":"architecture/validators/#nft-continuation-check","title":"NFT Continuation Check","text":"<p>Validates protocol NFT is preserved:</p> <pre><code># Check input has protocol NFT\ninput_value = own_input.resolved.value\nassert has_protocol_nft(input_value, own_policy)\n\n# Check output has same protocol NFT\noutput_value = own_output.value\nassert has_protocol_nft(output_value, own_policy)\nassert same_token_name(input_value, output_value, own_policy)\n</code></pre>"},{"location":"architecture/validators/#update-flow","title":"Update Flow","text":"<ol> <li>User submits transaction with <code>UpdateProtocol</code> redeemer</li> <li>Validator checks:</li> <li>Admin signature present</li> <li>Linear progression (1 input \u2192 1 output)</li> <li>Protocol NFT continues</li> <li>Immutable fields unchanged</li> <li>If all checks pass, transaction succeeds</li> <li>New datum with updates is stored in output</li> </ol>"},{"location":"architecture/validators/#end-flow","title":"End Flow","text":"<ol> <li>User submits transaction with <code>EndProtocol</code> redeemer</li> <li>Validator checks:</li> <li>Admin signature present</li> <li>Protocol NFT is burned (not in outputs)</li> <li>If checks pass, protocol terminates</li> <li>UTXO can be spent without continuing NFT</li> </ol>"},{"location":"architecture/validators/#validation-helpers","title":"Validation Helpers","text":""},{"location":"architecture/validators/#resolve_linear_input","title":"resolve_linear_input","text":"<p>Finds the single input containing a specific policy ID:</p> <pre><code>def resolve_linear_input(\n    inputs: List[TxInInfo],\n    policy_id: PolicyId\n) -&gt; TxInInfo:\n    \"\"\"\n    Returns the single input with the given policy.\n    Fails if zero or multiple inputs found.\n    \"\"\"\n</code></pre>"},{"location":"architecture/validators/#resolve_linear_output","title":"resolve_linear_output","text":"<p>Finds the single output at an address with a specific policy:</p> <pre><code>def resolve_linear_output(\n    outputs: List[TxOut],\n    address: Address,\n    policy_id: PolicyId\n) -&gt; TxOut:\n    \"\"\"\n    Returns the single output at address with the given policy.\n    Fails if zero or multiple outputs found.\n    \"\"\"\n</code></pre>"},{"location":"architecture/validators/#resolve_datum_from_output","title":"resolve_datum_from_output","text":"<p>Extracts and decodes datum from output:</p> <pre><code>def resolve_datum_from_output(output: TxOut) -&gt; DatumProtocol:\n    \"\"\"\n    Extracts datum from output and decodes to DatumProtocol.\n    Handles both inline datums and datum hashes.\n    \"\"\"\n</code></pre>"},{"location":"architecture/validators/#error-cases","title":"Error Cases","text":""},{"location":"architecture/validators/#unauthorized-update","title":"Unauthorized Update","text":"<pre><code>Error: \"Unauthorized: missing admin signature\"\nCause: Transaction not signed by any admin key\nFix: Include admin signature in transaction\n</code></pre>"},{"location":"architecture/validators/#state-fragmentation","title":"State Fragmentation","text":"<pre><code>Error: \"Multiple inputs with protocol NFT\"\nCause: Attempting to spend multiple protocol UTXOs\nFix: Only spend one protocol UTXO per transaction\n</code></pre>"},{"location":"architecture/validators/#immutable-field-change","title":"Immutable Field Change","text":"<pre><code>Error: \"Oracle ID is immutable\"\nCause: Attempted to change oracle_id in update\nFix: Keep oracle_id unchanged in new datum\n</code></pre>"},{"location":"architecture/validators/#missing-nft-continuation","title":"Missing NFT Continuation","text":"<pre><code>Error: \"Protocol NFT not in output\"\nCause: Output doesn't contain protocol NFT\nFix: Ensure protocol NFT is in exactly one output\n</code></pre>"},{"location":"architecture/validators/#best-practices","title":"Best Practices","text":""},{"location":"architecture/validators/#when-updating-protocol","title":"When Updating Protocol","text":"<ol> <li>Always include admin signature</li> <li>Preserve immutable fields (admin, oracle_id, project_id)</li> <li>Ensure linear progression (1 in \u2192 1 out)</li> <li>Include protocol NFT in output</li> </ol>"},{"location":"architecture/validators/#when-ending-protocol","title":"When Ending Protocol","text":"<ol> <li>Include admin signature</li> <li>Burn protocol NFT (don't include in outputs)</li> <li>Coordinate with user token burning</li> </ol>"},{"location":"architecture/validators/#testing-validators","title":"Testing Validators","text":"<pre><code>def test_protocol_update():\n    # Setup\n    datum = DatumProtocol(...)\n    redeemer = UpdateProtocol()\n    context = mock_script_context(...)\n\n    # Execute\n    result = protocol_validator(datum, redeemer, context)\n\n    # Assert\n    assert result is True\n</code></pre>"},{"location":"architecture/validators/#see-also","title":"See Also","text":"<ul> <li>Minting Policies - Token creation logic</li> <li>Types - Datum and redeemer definitions</li> <li>API Reference - Full API documentation</li> </ul>"},{"location":"contracts/details/","title":"Dise\u00f1o de Contratos Inteligentes","text":""},{"location":"contracts/details/#descripcion-de-tokens","title":"Descripci\u00f3n de tokens","text":"<p>La aplicaci\u00f3n hace uso de tokens tanto NFT como FT</p>"},{"location":"contracts/details/#tokens-nft","title":"Tokens NFT","text":"<p>Los tokens NFT se utilizan principalmente para permitir la identificaci\u00f3n de las UTXOs que pertenecen a la aplicaci\u00f3n para leer informaci\u00f3n sensible almacenada en datums, principalmente en direcciones de billeteras principales y direcciones de contratos.</p>"},{"location":"contracts/details/#tokens-ft","title":"Tokens FT","text":"<p>Existen dos tipos de tokens FT: tokens grises y tokens verdes.</p> <ul> <li>Tokens grises: estos son tokens que representan un porcentaje de participaci\u00f3n en el proyecto. Son una promesa futura de cr\u00e9ditos de carbono que ser\u00e1n certificados si el proyecto es exitoso. Estos tokens se crean en una proporci\u00f3n de 1 token/1 tonelada de CO2eq con un suministro total fijo correspondiente a la estimaci\u00f3n inicial. La estimaci\u00f3n tiene asociada una incertidumbre que se representa mediante una cantidad denominada buffer para tener flexibilidad durante la realizaci\u00f3n de los certificados y mantener el equilibrio real de los cr\u00e9ditos de carbono una vez confirmados.</li> <li>Tokens verdes: representan 1 tonelada de CO2eq certificada por una entidad de certificaci\u00f3n. La entidad de certificaci\u00f3n emite un certificado que se bloquea en el sistema y se tokeniza por la cantidad de cr\u00e9ditos de carbono establecida en el certificado en una proporci\u00f3n 1:1.</li> </ul>"},{"location":"contracts/details/#descripcion-tipos-de-contratos","title":"Descripci\u00f3n tipos de contratos","text":"<p>En cardano se pueden definir varios tipos de contrato, especificados en el campo \"purpose\" dentro del contexto de la transacci\u00f3n:</p> <pre><code>ScriptPurpose = Union[Minting, Spending, Rewarding, Certifying]\n</code></pre> <p>En nuestra aplicaci\u00f3n se van a utilizar \u00fanicamente dos, los cuales son los m\u00e1s comunes: de tipo \"Minting\" y de tipo \"Spending\"</p>"},{"location":"contracts/details/#contratos-de-tipo-minteo","title":"Contratos de tipo minteo","text":"<p>Se utilizan para crear tokens nativos y definir sus condiciones de creaci\u00f3n o quema. En nuestra aplicaci\u00f3n se pueden listar los siguientes:</p> <ul> <li>Para crear NFTs: usualmente crean un NFT de protocolo y un NFT de usuario siguiendo el est\u00e1ndar CIP68. Sirven como identificadores \u00fanicos para guardar informaci\u00f3n en datums (metadata) que los contrato de gasto pueden acceder como entrada en el proceso de validaci\u00f3n.</li> <li>Para crear o quemar tokens grises: a nivel de proyecto, controlan la creaci\u00f3n y quema de los FTs tokens grises.</li> <li>Para crear o quemar tokens verdes: a nivel de proyecto, controlan la creaci\u00f3n y quema de los FTs tokens verdes.</li> </ul>"},{"location":"contracts/details/#contratos-de-tipo-gasto","title":"Contratos de tipo gasto","text":"<p>Se utilizan para definir reglas de validaci\u00f3n para consumir utxos que contienen \"lovelace\" y/o tokens nativos, los cuales est\u00e1n alojados en la direcci\u00f3n del contrato. </p>"},{"location":"contracts/details/#lista-de-contratos-principales-y-su-arquitectura","title":"Lista de contratos principales y su arquitectura","text":""},{"location":"contracts/details/#contrato-nft-autorizacion-protocolo-tipo-minting","title":"Contrato NFT autorizaci\u00f3n protocolo (Tipo Minting)","text":"<p>Creaci\u00f3n de dos tokens de autorizaci\u00f3n (referencia y usuario) siguiendo la especificaci\u00f3n CIP68. Uno se env\u00eda a la billetera del usuario que crea el protocolo y el otro se env\u00eda a la direcci\u00f3n de gasto del contrato (Contrato Protocolo). El nombre del token se construye a partir de la UTXO de entrada (ID de entrada de transacci\u00f3n) y agregando un prefijo de la siguiente manera: REF_ para el NFT de referencia enviado al contrato, y USER_ enviado al usuario. Esto garantiza que los nombres de los tokens sean \u00fanicos y con un prefijo identificable.</p> <ul> <li>Par\u00e1metros</li> </ul> <pre><code>oref: TxOutRef\n</code></pre> <ul> <li>Redeemer</li> </ul> <pre><code>@dataclass()\nclass Mint(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 0\n@dataclass()\nclass Burn(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 1\n</code></pre>"},{"location":"contracts/details/#validaciones-del-contrato","title":"Validaciones del contrato","text":"<ol> <li>Valida que el prop\u00f3sito del contrato sea de tipo \"Minting\"</li> <li>Valida que 2 tokens sean creados o destruidos exactamente (1 reference, 1 usuario)</li> <li>Para minteo:<ol> <li>Valida que el par\u00e1metro utxo se consuma</li> <li>Valida que se crea un NFT de tipo protocolo</li> <li>Valida que se crea un NFT de tipo usuario</li> </ol> </li> <li>Para quema:<ol> <li>Valida que a la salida de la transacci\u00f3n no existan tokens con la misma pol\u00edtica del contrato Este contrato puede ser utilizado libremente sin ninguna restricci\u00f3n. Su objetivo es generar identificadores \u00fanicos cuyos tokens, tanto referencia como usuario, sean utilizados en conjunto para desbloquear transacciones que requieran un acceso de administrador. </li> </ol> </li> </ol>"},{"location":"contracts/details/#contrato-de-protocolo-tipo-spending","title":"Contrato de Protocolo (Tipo Spending)","text":"<p>Gestiona los par\u00e1metros del protocolo para un f\u00e1cil acceso en cadena. Contiene informaci\u00f3n en una UTXO, un datum sobre AdminWallet, OracleId, comisi\u00f3n durante la compra de tokens, listado de proyectos autorizados.</p> <p>Este contrato es responsable de salvaguardar la veracidad de la informaci\u00f3n contenida en su datum, actualizarlo y eliminarlo. </p> <ul> <li> <p>Par\u00e1metros <pre><code>token_policy_id: PolicyId\n</code></pre></p> </li> <li> <p>Redeemer <pre><code>@dataclass()\nclass UpdateProtocol(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 1\n\u00a0 \u00a0 protocol_input_index: int\n\u00a0 \u00a0 user_input_index: int\n\u00a0 \u00a0 protocol_output_index: int\n@dataclass()\nclass EndProtocol(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 2\n\u00a0 \u00a0 protocol_input_index: int\n\u00a0 \u00a0 user_input_index: int\n\nRedeemerProtocol = Union[UpdateProtocol, EndProtocol]\n</code></pre></p> </li> <li> <p>Datum <pre><code>@dataclass\nclass DatumProtocol(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 0\n\u00a0 \u00a0 protocol_admin: List[bytes] \u00a0# List of admin public key hashes\n\u00a0 \u00a0 protocol_fee: int \u00a0# Protocol fee in lovelace\n\u00a0 \u00a0 oracle_id: bytes \u00a0# Oracle identifier\n\u00a0 \u00a0 projects: List[bytes] \u00a0# Project identifier\n</code></pre></p> </li> </ul>"},{"location":"contracts/details/#validaciones-del-contrato_1","title":"Validaciones del contrato","text":"<ol> <li>Valida que el prop\u00f3sito del contrato sea de tipo \"Spending\"</li> <li>Valida que el input utilizado para encontrar el token de referencia sea el del protocolo oficial</li> <li>Valida que el usuario que est\u00e1 interactuando con el contrato tenga su token de autorizaci\u00f3n</li> <li>Valida que no se pueda utilizar m\u00e1s de un utxo a la vez proveniente de la direcci\u00f3n del contrato</li> <li>En UpdateProtocol<ol> <li>Valida que el token no se env\u00ede a una direcci\u00f3n distinta a la del contrato</li> <li>Valida que el datum se actualice de acuerdo a las siguientes restricciones:<ol> <li>Los fees del protocol &gt;= 0</li> <li>El n\u00famero de administradores de proyectos &lt;=10</li> <li>El n\u00famero de proyectos gestionados por el mismo protocolo &lt;=10</li> </ol> </li> </ol> </li> <li>Para EndProtocol<ol> <li>Valida que los tokens desaparezcan al ser quemados por el contrato de quema.</li> </ol> </li> </ol>"},{"location":"contracts/details/#consideraciones-generales","title":"Consideraciones generales","text":"<ul> <li>Cualquier persona o entidad puede desarrollar por completo el protocol con sus tokens de validaci\u00f3n. Sin embargo, los protocolos desplegados son completamente independientes de tal forma que los proyectos asociados en cada uno, son igualmente independientes. </li> <li>Cualquier persona que est\u00e9 en posesi\u00f3n del token de autorizaci\u00f3n est\u00e1 en la capacidad de realizar modificaciones al datum del protocolo.</li> <li>El token de referencia sirve para oficializar el utxo que tiene el datum con la informaci\u00f3n sensible del protocolo.</li> <li>El protocolo est\u00e1 dise\u00f1ado para nunca liberar el nft de referencia de su contrato. La \u00fanica salida posible es con el quemado del token y por lo tanto su fnalizaci\u00f3n. </li> </ul>"},{"location":"contracts/details/#posibles-ataques","title":"Posibles ataques","text":"<p>Una vez desplegado el protocolo los ataques se centran en los siguientes frentes: 1. Modificaci\u00f3n del datum por parte de usuarios no autorizados. 2. Sacar el token de la direcci\u00f3n del contrato. 3. Finalizar el protocolo quemando el token.</p> <p>Escenarios: - Que alguien env\u00ede un nft de referencia ficticio a la direcci\u00f3n del contrato y trate de desbloquear el nft original junto con el ficticio para modificar el datum del original.      - Salvaguarda: s\u00f3lo un utxo de la direcci\u00f3n del contrato puede ser consumido a la vez en una transacci\u00f3n.  - Que alguien env\u00ede \u00edndices de redeemers falsos para validar funciones del contrato que dependen de los \u00edndices que provee el usuario en el redeemer.     - Salvaguarda: el par\u00e1metro token_policy_id identifica el token oficial y por lo tanto todos los inputs de referencia deben contener el token oficial de acuerdo a este policy.</p>"},{"location":"contracts/details/#contrato-nft-autorizacion-proyecto","title":"Contrato NFT autorizaci\u00f3n proyecto","text":"<p>Creaci\u00f3n de dos tokens de autorizaci\u00f3n (referencia y usuario) siguiendo la especificaci\u00f3n CIP68. Uno se env\u00eda a la billetera del usuario que crea el proyecto y el otro se env\u00eda a la direcci\u00f3n de gasto del contrato (Contrato Proyecto). El nombre del token se construye a partir de la UTXO de entrada (ID de entrada de transacci\u00f3n) y agregando un prefijo de la siguiente manera: REF_ para el NFT de referencia enviado al contrato, y USER_ enviado al usuario. Esto garantiza que los nombres de los tokens sean \u00fanicos y con un prefijo identificable. </p> <p>Es un contrato similar al utilizado para el protocolo sin embargo tiene una validaci\u00f3n adicional y es que los que firman la transacci\u00f3n para poder generar estos tokens deben estar listados en el campo project_admins del DatumProtocol.</p> <ul> <li>Par\u00e1metros <pre><code>oref: TxOutRef,\nprotocol_policy_id: PolicyId\n</code></pre></li> <li>Redeemer <pre><code>@dataclass()\nclass MintProject(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 0\n\u00a0 \u00a0 protocol_input_index: int \u00a0# Index of the input UTXO to be consumed\n@dataclass()\nclass BurnProject(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 1\n\u00a0 \u00a0 protocol_input_index: int \u00a0# Index of the reference input UTXO\n</code></pre></li> </ul>"},{"location":"contracts/details/#validaciones-del-contrato_2","title":"Validaciones del contrato","text":"<ol> <li>Valida que el prop\u00f3sito del contrato sea de tipo \"Minting\"</li> <li>Valida que solamente se creen dos tipos de tokens</li> <li>Valida que el protocolo de referencia sea el correcto comp\u00e1rando la pol\u00edtica del protocolo</li> <li>Valida que el utxo del protocolo contenga el token esperado</li> <li>Valida que quien firma la transacci\u00f3n haga parta de la lista de administradores en el datum del protocolo</li> <li>Para minteo:<ol> <li>Valida que el par\u00e1metro utxo se consuma</li> <li>Valida que se crea un NFT de tipo protocolo</li> <li>Valida que se crea un NFT de tipo usuario</li> </ol> </li> <li>Para quema:<ol> <li>Valida que a la salida de la transacci\u00f3n no existan tokens con la misma pol\u00edtica del contrato</li> </ol> </li> </ol> <p>Este contrato est\u00e1 atado al protocolo utilizando la pol\u00edtica del protocolo como par\u00e1metro de inicializaci\u00f3n. Su objetivo es generar identificadores \u00fanicos cuyos tokens, tanto referencia como usuario, deben ser utilizados en conjunto para desbloquear transacciones asociadas a actualizaciones del proyecto. A trav\u00e9s de la validaci\u00f3n de los administradores listados en el datum del protocolo se determina qui\u00e9nes pueden crear o destruir estos certificados, y por lo tanto ser los administradores de proyectos.</p>"},{"location":"contracts/details/#contrato-de-proyecto-tipo-spending","title":"Contrato de Proyecto (tipo Spending)","text":"<p>Gestiona los datos y par\u00e1metros del proyecto. El datum contiene informaci\u00f3n relevante del proyecto como datos generales, as\u00ed como la econom\u00eda del token en cuanto a listado de participantes con sus proporciones y las reglas para su distribuci\u00f3n.  </p> <p>Este contrato es responsable de salvaguardar la veracidad de la informaci\u00f3n contenida en su datum, actualizarlo y eliminarlo. </p> <ul> <li> <p>Par\u00e1metros <pre><code>token_policy_id: PolicyId\n</code></pre></p> </li> <li> <p>Redeemer <pre><code>@dataclass()\nclass UpdateProject(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 1\n\u00a0 \u00a0 project_input_index: int\n\u00a0 \u00a0 user_input_index: int\n\u00a0 \u00a0 project_output_index: int\n@dataclass()\nclass UpdateToken(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 3\n\u00a0 \u00a0 project_input_index: int\n\u00a0 \u00a0 project_output_index: int\n@dataclass()\nclass EndProject(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 2\n\u00a0 \u00a0 project_input_index: int\n\u00a0 \u00a0 user_input_index: int\n\u00a0 \u00a0 \nRedeemerProject = Union[UpdateProject, UpdateToken, EndProject]\n</code></pre></p> </li> </ul> <p>El redeemer cuenta fundamentalmente con 3 acciones para interactuar con el contrato. 1. UpdateProject: se refiere a acciones administrativas para actualizar la informaci\u00f3n del datum. Estos cambios se pueden realizar antes de que el estado del proyecto sea &gt;=1 (distribuci\u00f3n). A partir de este estado, se entiende que los par\u00e1metros del proyecto deben permanecer constantes durante la duraci\u00f3n del mismo. 2. UpdateToken: Esta acci\u00f3n se utiliza en la creaci\u00f3n y quema de tokens grises por parte de participantes identificados con una llave p\u00fablica y participaci\u00f3n definida. Valida las acciones asociadas a su econom\u00eda como distribuci\u00f3n y validaci\u00f3n de topes permitidos para cada participante, actuando en conjunto con el contrato de tokens grises de tipo minteo.  3. EndProject: acci\u00f3n para terminar o clausurar el proyecto.</p> <ul> <li>Datum <pre><code>@dataclass()\nclass DatumProjectParams(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 1\n\u00a0 \u00a0 project_id: bytes \u00a0# Project Identifier\n\u00a0 \u00a0 project_metadata: bytes \u00a0# Metadata URI or hash\n\u00a0 \u00a0 project_state: int \u00a0# 0=initialized, 1=distributed, 2=certified 3=closed\n@dataclass()\nclass TokenProject(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 2\n\u00a0 \u00a0 policy_id: bytes \u00a0# Minting policy ID for the project tokens\n\u00a0 \u00a0 token_name: bytes \u00a0# Token name for the project tokens\n\u00a0 \u00a0 total_supply: int \u00a0# Total supply of tokens for the project (Grey tokens representing carbon credits promises)\n@dataclass()\nclass StakeHolderParticipation(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 3\n\u00a0 \u00a0 stakeholder: bytes \u00a0# Stakeholder public name (investor, landowner, verifier, etc.) Investor is a keyword that do not require pkh)\n\u00a0 \u00a0 pkh: bytes \u00a0# Stakeholder public key hash\n\u00a0 \u00a0 participation: int \u00a0# Participation amount in lovelace\n\u00a0 \u00a0 claimed: bool # Whether the stakeholder has claimed their share of tokens\n@dataclass()\nclass Certification(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 4\n\u00a0 \u00a0 certification_date: int \u00a0# Certification date as POSIX timestamp\n\u00a0 \u00a0 quantity: int \u00a0# Quantity of carbon credits certified\n\u00a0 \u00a0 real_certification_date: int \u00a0# Real certification date as POSIX timestamp (after verification)\n\u00a0 \u00a0 real_quantity: int \u00a0# Real quantity of carbon credits certified (after verification)\n@dataclass()\nclass DatumProject(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 0\n\u00a0 \u00a0 params: DatumProjectParams\n\u00a0 \u00a0 project_token: TokenProject\n\u00a0 \u00a0 stakeholders: List[StakeHolderParticipation] \u00a0# List of stakeholders and their participation\n\u00a0 \u00a0 certifications: List[Certification] \u00a0# List of certification info for the project\n</code></pre></li> </ul> <p>El DatumProject es una agrupaci\u00f3n de otros tipos de datos m\u00e1s complejos para la gesti\u00f3n y administraci\u00f3n del token gris del proyecto: 1. params: DatumProjectParams     1. project_id: identificador \u00fanico del proyecto     2. project_metadata: archivo de datos con informaci\u00f3n detallada del proyecto     3. project_state: estado del proyecto (0=inicializado; 1=distribu\u00eddo; 2=certificado; 3=cerrado) 2. project_token: TokenProject     1. policy_id: pol\u00edtica que gobierna los tokens grises     2. token_name: nombre del token del proyecto     3. total_supply: suministro total de tokens grises 3. stakeholders: Listado de participantes idenficados en la distribuci\u00f3n de tokens (propietarios, administrador, socios gestores, entidad certificadora, buffer)     1. stakeholder: Nombre identificador del participante     2. pkh: Llave p\u00fablica del participante     3. participation: Cantidad de tokens grises del proyecto     4. claimed: si el participante reclam\u00f3 su participaci\u00f3n 4. certifications: Listado con los periodos de certificaci\u00f3n normalmente de periodos quinquenales.     1. certification_date_i: fecha estimada para la certificaci\u00f3n periodo i     2. quantity_i: cantidad de cr\u00e9ditos a certificar periodo i     3. real_certification_date_i: fecha real de certificaci\u00f3n periodo i     4. real_quantity_i: cantidad de cr\u00e9ditos reales certificados periodo i</p>"},{"location":"contracts/details/#validaciones-del-contrato_3","title":"Validaciones del contrato","text":"<ol> <li>Valida que el prop\u00f3sito del contrato sea de tipo \"Spending\"</li> <li>Valida que el input utilizado para encontrar el token de referencia sea del proyecto oficial</li> <li>Valida que no se pueda utilizar m\u00e1s de un utxo a la vez proveniente de la direcci\u00f3n del contrato</li> <li> <p>En UpdateProject - Acci\u00f3n para actualizar el datum por parte de un administrador del contrato (billetera que contiene el token de usuario del proyecto)</p> <ol> <li>Valida que el usuario que est\u00e1 interactuando con el contrato tenga su token de autorizaci\u00f3n</li> <li>Valida que el token de referencia no se env\u00ede a una direcci\u00f3n distinta a la del contrato</li> <li>Valida que el datum se actualice de acuerdo a las siguientes restricciones:<ol> <li>El estado del proyecto, representado por un entero de 0 a 3 solamente puede aumentar, es decir, si se pasa al estado 1, no puede volver a su estado anterior.</li> <li>El estado del proyecto m\u00e1ximo es 3 ({0: \"Initialized\", 1: \"Distributed\", 2: \"Certified\", 3: \"Closed\"}).</li> <li>Se pueden cambiar todos los par\u00e1metros del datum si el estado del proyecto es 0 y siguiendo las siguientes reglas.<ol> <li>Par\u00e1metros posibles de actualizaci\u00f3n:<ol> <li>Estado del proyecto</li> <li>Suministro total</li> <li>Nombre del token gris</li> <li>Pol\u00edtica del token gris</li> <li>Participaci\u00f3n de los stakeholders</li> <li>Periodos para la certificaci\u00f3n</li> </ol> </li> <li>Restricciones:<ol> <li>Suministro total no puede ser negativo</li> <li>La suma de la participaci\u00f3n de los stakeholders debe ser menor o igual al suministro total</li> <li>La participaci\u00f3n de los stakeholders no puede ser negativa</li> <li>El indicador de redenci\u00f3n debe permanecer en falso durante el estado del proyecto igual a 0</li> <li>Los datos reales de certificaci\u00f3n deben ser 0 mientras el estado del proyecto no haya llegado a la etapa 2 (certificaci\u00f3n)</li> <li>Los datos de certificaci\u00f3n no pueden ser negativos</li> <li>La suma de las cantidades de certificaci\u00f3n debe ser igual al suministro total</li> </ol> </li> </ol> </li> <li>Si el estado del proyecto es mayor o igual a 1 todos los par\u00e1metros del proyecto se bloquean bajo esta acci\u00f3n del redeemer a excepci\u00f3n de:<ol> <li>Par\u00e1metros posibles de actualizaci\u00f3n:<ol> <li>Estado del proyecto</li> <li>Participaci\u00f3n de los stakeholders</li> <li>Periodos para la certificaci\u00f3n</li> </ol> </li> <li>Restricciones:<ol> <li>Bajo esta condici\u00f3n se encuentra en 1 inicialmente y puede seguir avanzando a 2 o 3 mas no disminuir</li> <li>\u00danicamente se permite actualizar el pkh de los stakeholders para que con esa llave p\u00fablica puedan reclamar los tokens grises que les correspondan</li> <li>\u00danicamente se pueden cambiar los valores de fecha y cantidad real para la certificaci\u00f3n, campos que se actualizan a medida que se van cumpliendo los hitos de certificaci\u00f3n del proyecto. Esto es posible y ocurre \u00fanicamente cuando el estado del proyecto es igual a 1</li> <li>Los periodos para la certificaci\u00f3n se mantienen constantes a partir del periodo 1. Sin embargo, a partir del periodo 2 es posible actualizar la fecha y cantidad real certificada teniendo en cuenta que no puede ser mayor a le fecha o cantidad inicialmente planeada.</li> </ol> </li> </ol> </li> </ol> </li> </ol> </li> <li> <p>En UpdateToken - Acci\u00f3n para permitir la creaci\u00f3n de tokens grises a stakeholders identificados en los campos de participaci\u00f3n del datum del proyecto.</p> <ol> <li>Valida que el token de referencia no se env\u00ede a una direcci\u00f3n distinta del contrato mismo</li> <li>Valida que el stakeholder aparezca en el listado de participantes, tenga una llave p\u00fablica registrada y firme con dicha llave. </li> <li>Valida que todos los campos del datum permanezcan constantes a excepci\u00f3n del par\u00e1metro claimed de los stakeholders.</li> <li>Solamente los stakeholders autorizados pueden cambiar el parametro claimed a True</li> </ol> </li> <li>En EndProject<ol> <li>Valida que el usuario que est\u00e1 interactuando con el contrato tenga su token de autorizaci\u00f3n</li> </ol> </li> </ol>"},{"location":"contracts/details/#minteo-de-tokens-grises","title":"Minteo de tokens grises","text":"<p>El minteo de tokens grises es validado en conjunto por el contrato de Proyecto y el contrato Gris Ver [[#Contrato de token grises (tipo Minting)]]. 1. El contrato de Proyecto (tipo Spending) para la validaci\u00f3n de la actualizaci\u00f3n del datum del proyecto. 2. El contrato Gris (tipo Minting).  Para la validaci\u00f3n de las pol\u00edticas y restricciones de minteo del token gris del proyecto asociado.</p> <p>Esto puede suceder en dos momentos distintos:</p> <ol> <li>Free-minting Bajo la acci\u00f3n de UpdateProject, cuando se pasa el proyecto del estado 0 a 1 (inicializado a distribu\u00eddo), el usuario administrador del contrato proyecto debe mintear los tokens grises destinados a la comercializaci\u00f3n en el marketplace para inversionistas. Esta transacci\u00f3n entonces es validada por dos contratos, en lo que se refiere a la actualizaci\u00f3n del datum del proyecto, por el contrato de proyecto, y en lo que se refiere a la cantidad de tokens y las pol\u00edticas de minteo por el contrato de tokens grises del proyecto asociado.</li> </ol> <p>Estos tokens grises se env\u00edan a la direcci\u00f3n del contrato de Inversi\u00f3n para custodia y comercializaci\u00f3n. </p> <p>[!Warning] Es mandatorio mintear los tokens grises destinados exclusivamente a los inversionistas para la venta, acci\u00f3n que se conoce como \"free-minting\". Si esta acci\u00f3n de minteo de tokens grises del proyecto no se realiza y el estado del proyecto pasa a 1, no ser\u00e1 posible crear tokens grises bajo esta modalidad y \u00fanicamente estar\u00e1n disponibles los tokens grises identificados dentro del listado de stakeholders.</p> <ol> <li>Minteo por parte de stakeholders identificados en el listado Bajo la acci\u00f3n de UpdateToken, los participantes identificados en el listado pueden redimir sus tokens grises en una sola operaci\u00f3n de minteo por exactamente la cantidad total espec\u00edficada. Tambi\u00e9n act\u00faan los dos contratos en conjunto, puesto que el contrato de proyecto actualiza su datum para contabilizar los participantes que ya redimieron (claimed=True). Esta acci\u00f3n s\u00f3lo se puede realizar cuando el estado del proyecto es igual a 1.</li> </ol>"},{"location":"contracts/details/#posibles-ataques_1","title":"Posibles ataques","text":"<p>Escenarios: - Dos operaciones de minteo modificando el suministro de distintos stakeholders en la misma transacci\u00f3n.</p>"},{"location":"contracts/details/#contrato-de-token-grises-tipo-minting","title":"Contrato de token grises (tipo Minting)","text":"<p>Gestiona la creaci\u00f3n y quema de tokens grises asociados a un proyecto utilizando como informaci\u00f3n de entrada principal la que se encuentra en el datum del proyecto, en particular la asociada a la econom\u00eda del token, a su distribuci\u00f3n y participaci\u00f3n. </p> <ul> <li> <p>Par\u00e1metros <pre><code>project_id: PolicyId\n</code></pre></p> </li> <li> <p>Redeemer <pre><code>@dataclass()\nclass Mint(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 0\n\u00a0 \u00a0 project_input_index: int\n\u00a0 \u00a0 project_output_index: int\n@dataclass()\nclass Burn(PlutusData):\n\u00a0 \u00a0 CONSTR_ID = 1\n</code></pre></p> </li> </ul>"},{"location":"contracts/details/#validaciones-del-contrato_4","title":"Validaciones del contrato","text":"<ol> <li>Valida que el prop\u00f3sito del contrato sea de tipo \"Minting\"</li> <li>Valida que un solo tipo de token (policyId y nombre) sea creado o destru\u00eddo</li> <li></li> <li>Para minteo:<ol> <li>Valida que se exista un utxo de entrada con el datum del proyecto y que ese utxo contenga el token de referencia del proyecto.</li> <li>Valida que el policyId del token gris registrado en el datum del proyecto sea igual al del contrato de token grises.</li> <li>Valida que se est\u00e9 creando el token con el nombre registrado en el datum del proyecto</li> <li>Valida que se creen cantidades positivas</li> <li>Valida el estado del proyecto para permitir acciones de minteo de la siguiente forma:<ol> <li>Periodo Free-minting:<ol> <li>El estado del proyecto debe pasar del estado 0 al 1.</li> <li>Valida que la cantidad a crear sea la diferencia entre el suministro total y la participaci\u00f3n total de los stakeholders.</li> </ol> </li> <li>Minteo de participantes listados:<ol> <li>Verifica que el estado del proyecto est\u00e9 en 1.</li> <li>Verifica que la transacci\u00f3n est\u00e9 firmada por un participante identificado en la lista y que corresponda al pkh listado</li> <li>S\u00f3lo la cantidad del participante firmante es la que puede mintear.</li> <li>Verifica que a la salida del datum del proyecto el estado de redenci\u00f3n (claimed) sea verdadero.</li> <li>Verifica que la direcci\u00f3n de env\u00edo de los tokens corresponda a la de la llave p\u00fablica (pkh) del firmante.</li> </ol> </li> </ol> </li> </ol> </li> </ol>"},{"location":"contracts/protocol-nfts/","title":"Protocol NFTs","text":"<p>Detailed documentation for the protocol NFT minting policy.</p> <p>Reference Implementation</p> <p>Source code: <code>src/terrasacha_contracts/minting_policies/protocol_nfts.py</code></p>"},{"location":"contracts/protocol-nfts/#coming-soon","title":"Coming Soon","text":"<p>This page will contain: - Detailed minting policy implementation - Token lifecycle management - Transaction examples - Best practices</p> <p>For now, see: - Minting Policies Overview - API Reference</p>"},{"location":"contracts/protocol-validator/","title":"Protocol Validator","text":"<p>Detailed documentation for the protocol validator contract.</p> <p>Reference Implementation</p> <p>Source code: <code>src/terrasacha_contracts/validators/protocol.py</code></p>"},{"location":"contracts/protocol-validator/#coming-soon","title":"Coming Soon","text":"<p>This page will contain: - Detailed validator implementation - Step-by-step execution flow - Transaction examples - Edge cases and error handling</p> <p>For now, see: - Validators Overview - API Reference</p>"},{"location":"contracts/validations/","title":"Contract Validations Reference","text":"<p>This document provides a comprehensive list of all validations performed by each contract in the Terrasacha protocol.</p>"},{"location":"contracts/validations/#project-contract-projectpy","title":"Project Contract (<code>project.py</code>)","text":"<p>The project contract validates ProjectDatum updates and stakeholder operations. It works in tandem with the grey token minting policy to ensure consistency.</p>"},{"location":"contracts/validations/#updateproject-path-validations","title":"UpdateProject Path Validations","text":"<p>Preconditions: - Transaction must consume exactly one project NFT input - User must possess the required protocol NFT</p> <p>Validations: 1. User Authorization    - User input must contain the required protocol token    - Only authorized users can update project parameters</p> <ol> <li>NFT Continuation</li> <li>Project NFT must continue to exactly one output</li> <li> <p>NFT amount must remain 1 in the output </p> </li> <li> <p>Datum Update Business Rules (<code>validate_datum_update</code>):</p> </li> </ol> <p>When project_state == 0 (Initialization Phase):    - Current supply can only increase    - Current supply \u2264 total supply    - Total supply &gt; 0, current supply \u2265 0    - Sum of stakeholder participation == total supply    - Certifications can only be added, not removed    - Real certification values can only increase</p> <p>When project_state &gt;= 1 (Locked Phase):    - ALL fields must remain completely immutable    - No changes allowed to any project parameters    - Project enters permanent locked state</p> <ol> <li>Project State Progression</li> <li>Project state can only move forward (0\u21921\u21922\u21923)</li> <li>Invalid states (&gt; 3) are rejected</li> </ol>"},{"location":"contracts/validations/#updatetoken-path-validations","title":"UpdateToken Path Validations","text":"<p>Preconditions: - Project state must be &gt; 0 (active project required) - Transaction must include token minting/burning</p> <p>Validations: 1. State Validation    - Project must be in active state (project_state &gt; 0)    - Cannot use UpdateToken during initialization phase</p> <ol> <li>Mint Amount Validation</li> <li>Minted/burned tokens must match redeemer.new_supply exactly</li> <li> <p>No discrepancies between declared and actual token operations</p> </li> <li> <p>Stakeholder Authorization (<code>validate_stakeholder_authorization</code>)</p> </li> <li>If non-investor stakeholders exist, at least one must sign transaction</li> <li>If only investor stakeholders exist, no signature required (public access)</li> <li> <p>Investor transactions are permissionless</p> </li> <li> <p>NFT Continuation</p> </li> <li>Project NFT must continue to exactly one output</li> <li> <p>NFT amount must remain 1</p> </li> <li> <p>Supply Updates (<code>validate_update_token_changes</code>)</p> </li> <li>Current supply = old_supply + mint_delta (exactly)</li> <li>Current supply \u2264 total supply</li> <li>Current supply \u2265 0</li> <li> <p>No over-minting or invalid supply states</p> </li> <li> <p>Field Immutability</p> </li> <li>Protocol policy ID cannot change</li> <li>Project ID, project state, metadata cannot change</li> <li>Token policy ID, token name, total supply cannot change</li> <li>Stakeholder structure (identity, PKH, participation) cannot change</li> <li> <p>All certification data cannot change</p> </li> <li> <p>Amount Claimed Updates</p> </li> <li>During Minting (mint_delta &gt; 0): amount_claimed can increase</li> <li>During Burning (mint_delta &lt; 0): amount_claimed can decrease</li> <li>Amount claimed \u2265 0 (no negative claims)</li> <li> <p>No cash refunds during burning operations</p> </li> <li> <p>Stakeholder Claim Limits</p> </li> <li>Amount claimed \u2264 stakeholder participation</li> <li>Amount claimed \u2264 total supply</li> <li>Non-investor stakeholders must sign for their own claim changes</li> <li>Investor claims are permissionless</li> </ol>"},{"location":"contracts/validations/#endproject-path-validations","title":"EndProject Path Validations","text":"<p>Preconditions: - User must possess the required protocol NFT</p> <p>Validations: 1. User Authorization    - User input must contain the required protocol token    - Only authorized users can end projects</p>"},{"location":"contracts/validations/#grey-token-minting-policy-greypy","title":"Grey Token Minting Policy (<code>grey.py</code>)","text":"<p>This minting policy validates token minting/burning operations and ensures they coordinate properly with the project contract datum updates.</p>"},{"location":"contracts/validations/#common-validations-both-mint-and-burn","title":"Common Validations (Both Mint and Burn)","text":"<ol> <li>Project Reference Validation (<code>validate_project_reference</code>)</li> <li>Transaction must have at least one reference input</li> <li>Reference input must contain project NFT with correct policy ID</li> <li>Project token policy ID must match this minting policy ID</li> <li> <p>Project state must be &gt; 0 (active state required)</p> </li> <li> <p>Token Operation Constraints</p> </li> <li>Must mint or burn exactly one token type</li> <li>Token name must match project datum token name</li> <li>Cannot operate on multiple token types simultaneously</li> </ol>"},{"location":"contracts/validations/#mint-operation-validations-validate_mint_operation","title":"Mint Operation Validations (<code>validate_mint_operation</code>)","text":"<p>Preconditions: - Redeemer must be of type <code>Mint</code> - Project must be in active state</p> <p>Validations: 1. Amount Validation    - Must mint exactly one token type    - Minted amount must be positive (&gt; 0)    - Token name must match project datum specification</p> <ol> <li>Supply Constraints</li> <li>Minted amount \u2264 remaining mintable supply (total - current)</li> <li>Cannot exceed total supply defined in project datum</li> <li> <p>Ensures token scarcity and prevents over-minting</p> </li> <li> <p>Project State Validation</p> </li> <li>Project must be in active state (project_state &gt; 0)</li> <li>Cannot mint during initialization phase</li> </ol>"},{"location":"contracts/validations/#burn-operation-validations-validate_burn_operation","title":"Burn Operation Validations (<code>validate_burn_operation</code>)","text":"<p>Preconditions: - Redeemer must be of type <code>Burn</code> - Tokens to burn must exist in circulation</p> <p>Validations: 1. Amount Validation    - Must burn exactly one token type    - Burned amount must be negative (in mint value representation)    - Token name must match project datum specification</p> <ol> <li>Supply Constraints</li> <li>Burned amount \u2264 current supply in circulation</li> <li>Cannot burn more tokens than exist</li> <li> <p>Prevents invalid burn operations</p> </li> <li> <p>Output Constraints</p> </li> <li>No tokens of this policy can be sent to outputs during burning</li> <li>Ensures complete token destruction</li> <li>Prevents partial burns or token retention</li> </ol>"},{"location":"contracts/validations/#coordination-with-project-contract","title":"Coordination with Project Contract","text":"<p>The grey minting policy works in coordination with the project contract:</p> <p>Project Contract Responsibilities: - Validates datum updates (current_supply, amount_claimed) - Enforces stakeholder authorization - Ensures immutable fields remain unchanged - Validates UpdateToken redeemer parameters</p> <p>Grey Minting Policy Responsibilities: - Validates actual token amounts being minted/burned - Ensures project reference input is correct and valid - Prevents over-minting beyond total supply - Prevents burning more than current supply - Enforces complete token destruction during burns</p> <p>Coordination Mechanism: - Both contracts must validate successfully for token operations - Reference input provides immutable project state for validation - Supply tracking ensures token economics remain consistent - Mint amounts must match between contracts</p>"},{"location":"contracts/validations/#protocol-contract-protocolpy","title":"Protocol Contract (<code>protocol.py</code>)","text":""},{"location":"contracts/validations/#updateprotocol-path-validations","title":"UpdateProtocol Path Validations","text":"<ol> <li>User Authorization</li> <li>User must possess the required protocol NFT</li> <li> <p>Only protocol admins can update protocol parameters</p> </li> <li> <p>NFT Continuation</p> </li> <li> <p>Protocol NFT must continue to exactly one output</p> </li> <li> <p>Datum Update Validation</p> </li> <li>Protocol parameters can be updated based on business rules</li> <li>Fee structures and admin lists can be modified</li> </ol>"},{"location":"contracts/validations/#endprotocol-path-validations","title":"EndProtocol Path Validations","text":"<ol> <li>User Authorization</li> <li>User must possess the required protocol NFT</li> <li>Only authorized users can end protocol</li> </ol>"},{"location":"contracts/validations/#key-security-principles","title":"Key Security Principles","text":"<ol> <li> <p>Linear Progression: All contracts enforce one-input-to-one-output patterns to prevent state fragmentation</p> </li> <li> <p>Immutability After Lock: Once project state \u2265 1, core parameters become immutable</p> </li> <li> <p>Supply Conservation: Token supply is strictly tracked and enforced across all operations</p> </li> <li> <p>Authorization Hierarchy: Different stakeholder types have different permission levels</p> </li> <li> <p>Reference Input Validation: Immutable project state is used for validation across contracts</p> </li> <li> <p>Atomic Operations: All validations must pass for transaction success</p> </li> <li> <p>No Partial Operations: Token operations are all-or-nothing to maintain consistency</p> </li> </ol>"},{"location":"development/build-system/","title":"Build System","text":"<p>Understanding the contract build system in Terrasacha Contracts.</p>"},{"location":"development/build-system/#overview","title":"Overview","text":"<p>Contracts are written in Python (OpShin) and compiled to Plutus for on-chain deployment.</p>"},{"location":"development/build-system/#build-process","title":"Build Process","text":"<pre><code>OpShin Source (.py)\n      \u2193\nOpShin Compiler\n      \u2193\n   \u250c\u2500\u2500\u2534\u2500\u2500\u2510\n   \u2193     \u2193\n.plutus  .cbor\n(JSON)   (Binary)\n</code></pre>"},{"location":"development/build-system/#output-formats","title":"Output Formats","text":"<p><code>.plutus</code> (JSON): - Human-readable - Useful for debugging - Can be inspected with text editors - Used for testing and verification</p> <p><code>.cbor</code> (Binary): - Compact format - Used for on-chain deployment - More efficient storage - Required by Cardano node</p>"},{"location":"development/build-system/#building-contracts","title":"Building Contracts","text":""},{"location":"development/build-system/#build-all-contracts","title":"Build All Contracts","text":"<pre><code>uv run python src/scripts/build_contracts.py\n</code></pre> <p>This compiles: - All validators in <code>src/terrasacha_contracts/validators/</code> - All minting policies in <code>src/terrasacha_contracts/minting_policies/</code> - Outputs to <code>artifacts/</code> directory</p>"},{"location":"development/build-system/#build-individual-contract","title":"Build Individual Contract","text":"<p>Validator: <pre><code>uv run opshin compile src/terrasacha_contracts/validators/protocol.py\n</code></pre></p> <p>Minting policy: <pre><code>uv run opshin compile src/terrasacha_contracts/minting_policies/protocol_nfts.py\n</code></pre></p>"},{"location":"development/build-system/#interactive-build","title":"Interactive Build","text":"<p>Use the CLI menu: <pre><code>uv run python src/scripts/cli_menu.py\n</code></pre></p> <p>Options: - Option 2: Compile/Recompile All Contracts (full) - Option 3: Compile New Project Contract Only (fast)</p>"},{"location":"development/build-system/#artifacts-directory","title":"Artifacts Directory","text":"<p>After building:</p> <pre><code>artifacts/\n\u251c\u2500\u2500 validators/\n\u2502   \u251c\u2500\u2500 protocol.plutus      # JSON format\n\u2502   \u2514\u2500\u2500 protocol.cbor         # Binary format\n\u2514\u2500\u2500 minting_policies/\n    \u251c\u2500\u2500 protocol_nfts.plutus\n    \u2514\u2500\u2500 protocol_nfts.cbor\n</code></pre>"},{"location":"development/build-system/#build-script","title":"Build Script","text":""},{"location":"development/build-system/#location","title":"Location","text":"<p><code>src/scripts/build_contracts.py</code></p>"},{"location":"development/build-system/#features","title":"Features","text":"<ul> <li>Automatic discovery of contracts</li> <li>Parallel compilation (faster)</li> <li>Error reporting</li> <li>Artifact organization</li> </ul>"},{"location":"development/build-system/#configuration","title":"Configuration","text":"<p>OpShin version: <code>&gt;=0.26.0</code> (specified in <code>pyproject.toml</code>)</p>"},{"location":"development/build-system/#compilation-options","title":"Compilation Options","text":""},{"location":"development/build-system/#standard-compilation","title":"Standard Compilation","text":"<pre><code>uv run opshin compile &lt;contract_file&gt;\n</code></pre>"},{"location":"development/build-system/#with-optimization","title":"With Optimization","text":"<pre><code>uv run opshin compile --optimize &lt;contract_file&gt;\n</code></pre>"},{"location":"development/build-system/#generate-only-cbor","title":"Generate Only CBOR","text":"<pre><code>uv run opshin compile --cbor-only &lt;contract_file&gt;\n</code></pre>"},{"location":"development/build-system/#verification","title":"Verification","text":""},{"location":"development/build-system/#inspect-plutus-output","title":"Inspect Plutus Output","text":"<pre><code>cat artifacts/validators/protocol.plutus | jq .\n</code></pre>"},{"location":"development/build-system/#check-cbor-size","title":"Check CBOR Size","text":"<pre><code>ls -lh artifacts/validators/protocol.cbor\n</code></pre>"},{"location":"development/build-system/#verify-compilation","title":"Verify Compilation","text":"<p>Run contract tests: <pre><code>uv run pytest -m contracts\n</code></pre></p>"},{"location":"development/build-system/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/build-system/#compilation-errors","title":"Compilation Errors","text":"<p>Syntax errors: <pre><code># Check Python syntax\npython -m py_compile src/terrasacha_contracts/validators/protocol.py\n</code></pre></p> <p>Type errors: <pre><code># Run type checker\nuv run mypy src/terrasacha_contracts/\n</code></pre></p> <p>OpShin errors: <pre><code># Check OpShin version\nuv run opshin --version\n\n# Update OpShin\nuv add opshin --upgrade\n</code></pre></p>"},{"location":"development/build-system/#clean-build","title":"Clean Build","text":"<p>Remove old artifacts: <pre><code>rm -rf artifacts/\nuv run python src/scripts/build_contracts.py\n</code></pre></p>"},{"location":"development/build-system/#build-performance","title":"Build Performance","text":"<p>Optimize build time: <pre><code># Use faster compilation (skip optimizations)\nexport OPSHIN_FAST_BUILD=1\nuv run python src/scripts/build_contracts.py\n</code></pre></p>"},{"location":"development/build-system/#best-practices","title":"Best Practices","text":""},{"location":"development/build-system/#before-committing","title":"Before Committing","text":"<ol> <li>Clean build all contracts</li> <li>Run contract tests</li> <li>Verify artifact sizes reasonable</li> <li>Check for compilation warnings</li> </ol> <pre><code>rm -rf artifacts/\nuv run python src/scripts/build_contracts.py\nuv run pytest -m contracts\n</code></pre>"},{"location":"development/build-system/#version-control","title":"Version Control","text":"<p>Do commit: - Source contracts (<code>.py</code> files) - Build scripts - Test files</p> <p>Don't commit (add to <code>.gitignore</code>): - Artifacts directory - Compilation cache - Temporary files</p>"},{"location":"development/build-system/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"development/build-system/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>- name: Build contracts\n  run: |\n    uv sync\n    uv run python src/scripts/build_contracts.py\n\n- name: Test contracts\n  run: |\n    uv run pytest -m contracts\n</code></pre>"},{"location":"development/build-system/#see-also","title":"See Also","text":"<ul> <li>Development Guide</li> <li>CLI Tools</li> <li>OpShin Documentation</li> </ul>"},{"location":"development/claude-guide/","title":"CLAUDE.md","text":"<p>This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.</p>"},{"location":"development/claude-guide/#development-commands","title":"Development Commands","text":"<pre><code># Install dependencies\nuv sync\n\n# Install with dev dependencies\nuv sync --extra dev\n\n# Activate virtual environment\nsource .venv/bin/activate\n\n# Build all contracts\nuv run python src/scripts/build_contracts.py\n\n# Alternative: Use the CLI menu for interactive contract compilation\n# - Option 2: Compile/Recompile All Contracts (full compilation)\n# - Option 3: Compile New Project Contract Only (fast, protocol must exist)\n\n# Run tests\nuv run pytest\n\n# Run specific test file\nuv run pytest tests/test_protocols.py\n\n# Run tests with coverage\nuv run pytest --cov=src\n\n# Format code\nuv run ruff format .\n\n# Sort imports\nuv run ruff check --select I --fix .\n\n# Lint and fix issues\nuv run ruff check --fix .\n\n# Type checking\nuv run mypy .\n\n# Compile individual contract\nuv run opshin compile src/terrasacha_contracts/validators/protocol.py\nuv run opshin compile src/terrasacha_contracts/minting_policies/protocol_nfts.py\n\n# Update dependencies\nuv lock --upgrade\nuv sync\n\n# Add new dependency\nuv add &lt;package-name&gt;\n\n# Add dev dependency\nuv add --dev &lt;package-name&gt;\n</code></pre>"},{"location":"development/claude-guide/#project-architecture","title":"Project Architecture","text":"<p>This is a Cardano smart contract project built with OpShin that implements a protocol for carbon credit tokens and NFTs. The architecture follows a modular design:</p>"},{"location":"development/claude-guide/#core-components","title":"Core Components","text":"<p>Validators (<code>src/terrasacha_contracts/validators/</code>): - <code>protocol.py</code>: Main protocol validator handling protocol NFT validation and datum updates   - Validates protocol NFT continuation across transactions   - Handles protocol updates with proper authorization checks   - Implements linear progression patterns (one input \u2192 one output)</p> <p>Minting Policies (<code>src/terrasacha_contracts/minting_policies/</code>): - <code>protocol_nfts.py</code>: Mints paired NFTs (protocol + user tokens) with unique names derived from UTXO references   - Enforces exactly 2 tokens per mint (1 protocol, 1 user)   - Uses UTXO reference for uniqueness guarantee   - Handles both minting and burning operations</p> <p>Types (<code>src/terrasacha_contracts/types.py</code>): - <code>DatumProtocol</code>: Protocol state containing admin keys, fees, oracle/project IDs - <code>Mint/Burn</code>: Minting policy redeemers - <code>UpdateProtocol/EndProtocol</code>: Protocol validator redeemers - Token prefixes: <code>PROTO_</code> for protocol NFTs, <code>USER_</code> for user NFTs</p> <p>Utilities (<code>src/terrasacha_contracts/util.py</code>): - Linear validation helpers (<code>resolve_linear_input</code>, <code>resolve_linear_output</code>) - Token name generation with UTXO-based uniqueness - Purpose extraction and UTXO validation functions</p>"},{"location":"development/claude-guide/#key-design-patterns","title":"Key Design Patterns","text":"<ol> <li>Linear Progression: Contracts enforce one-input-to-one-output patterns to prevent state fragmentation</li> <li>Paired Token System: Protocol and user NFTs are minted together with shared unique suffixes</li> <li>Datum Immutability: Core protocol parameters (admin, oracle_id, project_id) cannot be changed</li> <li>UTXO-Based Uniqueness: Token names derived from consuming specific UTXOs ensure global uniqueness</li> </ol>"},{"location":"development/claude-guide/#build-system","title":"Build System","text":"<ul> <li>Contracts compile to both <code>.plutus</code> (JSON format) and <code>.cbor</code> (binary) in <code>artifacts/</code></li> <li>Build script automatically processes all validators and minting policies</li> <li>OpShin version pinned to 0.24.x for compatibility</li> </ul>"},{"location":"development/claude-guide/#testing","title":"Testing","text":"<ul> <li>Uses pytest with comprehensive coverage reporting</li> <li>Test markers: <code>slow</code>, <code>integration</code>, <code>unit</code>, <code>performance</code>, <code>contracts</code></li> <li>Mock utilities in <code>tests/mock.py</code> and <code>tests/tool.py</code></li> <li>Ledger compatibility testing with both API v1 and v2</li> </ul> <p>The codebase follows strict typing with mypy and uses black/isort for consistent formatting.</p>"},{"location":"development/cli-tools/","title":"CLI Tools","text":"<p>Command-line tools and utilities for Terrasacha Contracts development.</p>"},{"location":"development/cli-tools/#coming-soon","title":"Coming Soon","text":"<p>Documentation for: - Interactive CLI menu - Build tools - Deployment scripts - Utility commands</p> <p>For now, see: - Build System - Development Guide</p>"},{"location":"development/contributing/","title":"Contributing","text":"<p>Thank you for considering contributing to Terrasacha Contracts!</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository</li> <li>Clone your fork locally</li> <li>Install dependencies: <code>uv sync --extra dev</code></li> <li>Create a feature branch: <code>git checkout -b feature/your-feature</code></li> </ol>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":"<p>See: Development Guide</p>"},{"location":"development/contributing/#code-quality-standards","title":"Code Quality Standards","text":"<p>All contributions must pass:</p> <ul> <li>\u2705 Code formatting (ruff format)</li> <li>\u2705 Import sorting (ruff check --select I)</li> <li>\u2705 Linting (ruff check)</li> <li>\u2705 Type checking (mypy)</li> <li>\u2705 All tests passing (pytest)</li> <li>\u2705 Test coverage maintained or improved</li> </ul>"},{"location":"development/contributing/#pre-commit-checklist","title":"Pre-Commit Checklist","text":"<pre><code># Format code\nuv run ruff format .\n\n# Sort imports\nuv run ruff check --select I --fix .\n\n# Lint\nuv run ruff check --fix .\n\n# Type check\nuv run mypy .\n\n# Run tests\nuv run pytest\n\n# Build contracts\nuv run python src/scripts/build_contracts.py\n</code></pre>"},{"location":"development/contributing/#commit-message-format","title":"Commit Message Format","text":"<p>Follow conventional commits:</p> <pre><code>type: brief description\n\nLonger explanation if needed\n\nTypes:\n- feat: New feature\n- fix: Bug fix\n- docs: Documentation changes\n- test: Test additions/changes\n- refactor: Code refactoring\n- perf: Performance improvements\n- chore: Maintenance tasks\n</code></pre> <p>Examples: <pre><code>feat: add burn validation to protocol NFTs\nfix: resolve datum immutability check\ndocs: update architecture overview\ntest: add integration tests for minting\n</code></pre></p>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Ensure all checks pass locally</li> <li>Update documentation if needed</li> <li>Add/update tests for new functionality</li> <li>Push to your fork</li> <li>Create pull request with clear description</li> <li>Address review comments</li> <li>Wait for approval and merge</li> </ol>"},{"location":"development/contributing/#code-review","title":"Code Review","text":"<p>What reviewers look for:</p> <ul> <li>Code correctness and safety</li> <li>Test coverage</li> <li>Documentation quality</li> <li>Performance considerations</li> <li>Security implications</li> <li>Consistency with codebase</li> </ul>"},{"location":"development/contributing/#testing-requirements","title":"Testing Requirements","text":"<ul> <li>New features must include tests</li> <li>Maintain &gt;80% code coverage</li> <li>Tests must pass on all platforms</li> <li>Use appropriate test markers</li> </ul>"},{"location":"development/contributing/#documentation-requirements","title":"Documentation Requirements","text":"<ul> <li>Update relevant documentation</li> <li>Add docstrings to new functions</li> <li>Include code examples where helpful</li> <li>Keep documentation accurate</li> </ul>"},{"location":"development/contributing/#questions","title":"Questions?","text":"<ul> <li>Open an issue for discussion</li> <li>Check existing issues and PRs</li> <li>Review documentation thoroughly</li> </ul>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful, inclusive, and professional in all interactions.</p>"},{"location":"getting-started/development/","title":"Development Guide","text":"<p>Learn the recommended development workflow for Terrasacha Contracts.</p>"},{"location":"getting-started/development/#development-cycle","title":"Development Cycle","text":""},{"location":"getting-started/development/#1-feature-development","title":"1. Feature Development","text":"<pre><code># Create a new feature branch\ngit checkout -b feature/your-feature-name\n\n# Install dependencies (if not already done)\nuv sync --extra dev\n\n# Make your changes and test iteratively\nuv run pytest -v -m \"not slow\"  # Fast feedback loop\n</code></pre>"},{"location":"getting-started/development/#2-code-quality-checks","title":"2. Code Quality Checks","text":"<p>Before committing, ensure code quality:</p> <pre><code># Format code\nuv run ruff format .\n\n# Sort imports\nuv run ruff check --select I --fix .\n\n# Lint and fix issues\nuv run ruff check --fix .\n\n# Type checking\nuv run mypy .\n</code></pre>"},{"location":"getting-started/development/#3-testing","title":"3. Testing","text":"<p>Run comprehensive tests:</p> <pre><code># All tests\nuv run pytest\n\n# With coverage report\nuv run pytest --cov=src --cov-report=html\n\n# Specific test markers\nuv run pytest -m unit          # Unit tests only\nuv run pytest -m integration   # Integration tests only\nuv run pytest -m contracts     # Contract tests only\nuv run pytest -m \"not slow\"    # Fast tests only\n</code></pre>"},{"location":"getting-started/development/#4-building-contracts","title":"4. Building Contracts","text":"<pre><code># Build all contracts\nuv run python src/scripts/build_contracts.py\n\n# Or use the interactive CLI menu\nuv run python src/scripts/cli_menu.py\n# Then select:\n# - Option 2: Compile/Recompile All Contracts\n# - Option 3: Compile New Project Contract Only (faster)\n</code></pre>"},{"location":"getting-started/development/#project-commands","title":"Project Commands","text":""},{"location":"getting-started/development/#dependency-management","title":"Dependency Management","text":"<pre><code># Add new dependency\nuv add &lt;package-name&gt;\n\n# Add dev dependency\nuv add --dev &lt;package-name&gt;\n\n# Update all dependencies\nuv lock --upgrade\nuv sync\n\n# Show outdated packages\nuv pip list --outdated\n</code></pre>"},{"location":"getting-started/development/#opshin-commands","title":"OpShin Commands","text":"<pre><code># Compile a contract\nuv run opshin compile &lt;contract_file&gt;\n\n# Evaluate a contract (useful for testing)\nuv run opshin eval &lt;contract_file&gt;\n\n# Get OpShin help\nuv run opshin --help\n</code></pre>"},{"location":"getting-started/development/#code-standards","title":"Code Standards","text":""},{"location":"getting-started/development/#formatting","title":"Formatting","text":"<p>The project uses ruff for formatting with these settings:</p> <ul> <li>Line length: 120 characters</li> <li>Quote style: double quotes</li> <li>Target version: Python 3.11</li> </ul>"},{"location":"getting-started/development/#import-organization","title":"Import Organization","text":"<p>Imports are organized into sections:</p> <ol> <li>Future imports</li> <li>Standard library</li> <li>Third-party packages</li> <li>First-party (terrasacha_contracts)</li> <li>Local folder imports</li> </ol>"},{"location":"getting-started/development/#type-checking","title":"Type Checking","text":"<p>All code must pass mypy type checking:</p> <ul> <li>Strict mode enabled</li> <li>No untyped definitions allowed</li> <li>OpShin contracts excluded from type checking</li> </ul>"},{"location":"getting-started/development/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"getting-started/development/#test-markers","title":"Test Markers","text":"<p>Use pytest markers to organize tests:</p> <pre><code>@pytest.mark.unit\ndef test_validator_logic():\n    pass\n\n@pytest.mark.integration\ndef test_contract_interaction():\n    pass\n\n@pytest.mark.slow\ndef test_full_workflow():\n    pass\n\n@pytest.mark.contracts\ndef test_contract_compilation():\n    pass\n</code></pre>"},{"location":"getting-started/development/#test-structure","title":"Test Structure","text":"<pre><code>def test_function_name():\n    # Arrange - Set up test data\n    datum = DatumProtocol(...)\n\n    # Act - Execute the function\n    result = validator(datum, redeemer, context)\n\n    # Assert - Verify the result\n    assert result is True\n</code></pre>"},{"location":"getting-started/development/#coverage-goals","title":"Coverage Goals","text":"<ul> <li>Maintain or improve test coverage</li> <li>Aim for &gt;80% coverage on critical paths</li> <li>All new features must include tests</li> </ul>"},{"location":"getting-started/development/#git-workflow","title":"Git Workflow","text":""},{"location":"getting-started/development/#commit-messages","title":"Commit Messages","text":"<p>Follow conventional commits:</p> <pre><code>feat: add new minting policy for carbon credits\nfix: resolve validation issue in protocol validator\ndocs: update architecture documentation\ntest: add integration tests for NFT minting\nrefactor: simplify UTXO resolution logic\n</code></pre>"},{"location":"getting-started/development/#pre-commit-checklist","title":"Pre-Commit Checklist","text":"<p>Before committing:</p> <ul> <li> Code is formatted (<code>uv run ruff format .</code>)</li> <li> Imports are sorted (<code>uv run ruff check --select I --fix .</code>)</li> <li> No lint errors (<code>uv run ruff check --fix .</code>)</li> <li> Type checking passes (<code>uv run mypy .</code>)</li> <li> Tests pass (<code>uv run pytest</code>)</li> <li> Contracts compile (<code>uv run python src/scripts/build_contracts.py</code>)</li> </ul>"},{"location":"getting-started/development/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Create feature branch from <code>main</code></li> <li>Make changes with good commit messages</li> <li>Ensure all checks pass locally</li> <li>Push branch and create pull request</li> <li>Address review comments</li> <li>Squash and merge when approved</li> </ol>"},{"location":"getting-started/development/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/development/#clear-caches","title":"Clear Caches","text":"<p>If you encounter issues:</p> <pre><code># Clear Python cache\nfind . -type d -name __pycache__ -exec rm -rf {} +\n\n# Clear pytest cache\nrm -rf .pytest_cache\n\n# Clear mypy cache\nrm -rf .mypy_cache\n\n# Clear build artifacts\nrm -rf artifacts/\n</code></pre>"},{"location":"getting-started/development/#dependency-issues","title":"Dependency Issues","text":"<pre><code># Reset virtual environment\nrm -rf .venv\nuv sync --extra dev\n</code></pre>"},{"location":"getting-started/development/#contract-compilation-errors","title":"Contract Compilation Errors","text":"<p>Check OpShin version compatibility:</p> <pre><code>uv run opshin --version  # Should be 0.26.x or compatible\n</code></pre>"},{"location":"getting-started/development/#ide-configuration","title":"IDE Configuration","text":""},{"location":"getting-started/development/#vs-code","title":"VS Code","text":"<p>Recommended extensions:</p> <ul> <li>Python</li> <li>Pylance</li> <li>Ruff</li> <li>Even Better TOML</li> </ul> <p>Settings (<code>.vscode/settings.json</code>):</p> <pre><code>{\n  \"python.defaultInterpreterPath\": \".venv/bin/python\",\n  \"python.linting.enabled\": true,\n  \"python.linting.ruffEnabled\": true,\n  \"python.formatting.provider\": \"none\",\n  \"[python]\": {\n    \"editor.defaultFormatter\": \"charliermarsh.ruff\",\n    \"editor.formatOnSave\": true,\n    \"editor.codeActionsOnSave\": {\n      \"source.organizeImports\": true\n    }\n  }\n}\n</code></pre>"},{"location":"getting-started/development/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture Overview</li> <li>API Reference</li> <li>Testing Guide</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you set up the Terrasacha Contracts development environment.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: 3.11 or 3.12 (required by OpShin)</li> <li>Git: For cloning the repository</li> <li>uv: Fast Python package manager</li> </ul>"},{"location":"getting-started/installation/#step-1-install-uv","title":"Step 1: Install uv","text":"<p>Install uv package manager:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Verify installation:</p> <pre><code>uv --version\n</code></pre>"},{"location":"getting-started/installation/#step-2-clone-the-repository","title":"Step 2: Clone the Repository","text":"<pre><code>git clone https://github.com/SuanBlockchain/terrasacha-contracts.git\ncd terrasacha-contracts\n</code></pre>"},{"location":"getting-started/installation/#step-3-install-dependencies","title":"Step 3: Install Dependencies","text":"<p>Install all dependencies:</p> <pre><code>uv sync\n</code></pre> <p>Or with development dependencies (recommended):</p> <pre><code>uv sync --extra dev\n</code></pre> <p>This will: - Create a virtual environment in <code>.venv/</code> - Install all required packages including OpShin, pytest, ruff, mypy - Lock dependency versions</p>"},{"location":"getting-started/installation/#step-4-activate-virtual-environment","title":"Step 4: Activate Virtual Environment","text":"<pre><code>source .venv/bin/activate\n</code></pre>"},{"location":"getting-started/installation/#step-5-verify-installation","title":"Step 5: Verify Installation","text":"<p>Check that OpShin is installed correctly:</p> <pre><code>uv run opshin --version\n</code></pre> <p>Run tests to verify setup:</p> <pre><code>uv run pytest\n</code></pre>"},{"location":"getting-started/installation/#environment-variables-optional","title":"Environment Variables (Optional)","text":"<p>For blockchain interaction, create a <code>.env</code> file:</p> <pre><code>BLOCKFROST_PROJECT_ID=your_blockfrost_project_id\nNETWORK=testnet  # or mainnet\nWALLET_MNEMONIC=your_wallet_mnemonic_phrase\n</code></pre>"},{"location":"getting-started/installation/#development-tools","title":"Development Tools","text":"<p>The project includes several development tools:</p> <ul> <li>ruff: Fast linter and formatter</li> <li>mypy: Static type checker</li> <li>pytest: Testing framework with coverage support</li> </ul>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Build your first contract</li> <li>Development Guide - Learn the development workflow</li> </ul>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#python-version-issues","title":"Python Version Issues","text":"<p>Ensure you're using Python 3.11 or 3.12:</p> <pre><code>python --version\n</code></pre>"},{"location":"getting-started/installation/#dependency-conflicts","title":"Dependency Conflicts","text":"<p>If you encounter version conflicts, try:</p> <pre><code>uv lock --upgrade\nuv sync\n</code></pre>"},{"location":"getting-started/installation/#permission-issues","title":"Permission Issues","text":"<p>On Unix systems, you may need to make scripts executable:</p> <pre><code>chmod +x src/scripts/build_contracts.py\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get up and running with Terrasacha Contracts in minutes.</p>"},{"location":"getting-started/quickstart/#build-your-first-contract","title":"Build Your First Contract","text":""},{"location":"getting-started/quickstart/#1-compile-all-contracts","title":"1. Compile All Contracts","text":"<p>Build all contracts at once:</p> <pre><code>uv run python src/scripts/build_contracts.py\n</code></pre> <p>This compiles: - All validators in <code>src/terrasacha_contracts/validators/</code> - All minting policies in <code>src/terrasacha_contracts/minting_policies/</code> - Outputs to <code>artifacts/</code> directory in both <code>.plutus</code> (JSON) and <code>.cbor</code> (binary) formats</p>"},{"location":"getting-started/quickstart/#2-compile-individual-contracts","title":"2. Compile Individual Contracts","text":"<p>Compile a specific validator:</p> <pre><code>uv run opshin compile src/terrasacha_contracts/validators/protocol.py\n</code></pre> <p>Compile a specific minting policy:</p> <pre><code>uv run opshin compile src/terrasacha_contracts/minting_policies/protocol_nfts.py\n</code></pre>"},{"location":"getting-started/quickstart/#run-tests","title":"Run Tests","text":"<p>Run all tests:</p> <pre><code>uv run pytest\n</code></pre> <p>Run specific test file:</p> <pre><code>uv run pytest tests/test_protocols.py\n</code></pre> <p>Run with coverage report:</p> <pre><code>uv run pytest --cov=src\n</code></pre> <p>Run fast tests only (exclude slow/integration):</p> <pre><code>uv run pytest -v -m \"not slow\"\n</code></pre>"},{"location":"getting-started/quickstart/#code-quality","title":"Code Quality","text":""},{"location":"getting-started/quickstart/#format-code","title":"Format Code","text":"<pre><code>uv run ruff format .\n</code></pre>"},{"location":"getting-started/quickstart/#sort-imports","title":"Sort Imports","text":"<pre><code>uv run ruff check --select I --fix .\n</code></pre>"},{"location":"getting-started/quickstart/#lint-code","title":"Lint Code","text":"<pre><code>uv run ruff check --fix .\n</code></pre>"},{"location":"getting-started/quickstart/#type-checking","title":"Type Checking","text":"<pre><code>uv run mypy .\n</code></pre>"},{"location":"getting-started/quickstart/#development-workflow","title":"Development Workflow","text":"<ol> <li>Make changes to contracts in <code>src/terrasacha_contracts/</code></li> <li>Format and lint your code</li> <li>Run tests to ensure everything works</li> <li>Compile contracts to generate artifacts</li> <li>Commit your changes</li> </ol>"},{"location":"getting-started/quickstart/#quick-pre-commit-check","title":"Quick Pre-Commit Check","text":"<pre><code># Format, lint, and run fast tests\nuv run ruff format . &amp;&amp; \\\nuv run ruff check --fix . &amp;&amp; \\\nuv run pytest -v -m \"not slow\"\n</code></pre>"},{"location":"getting-started/quickstart/#understanding-artifacts","title":"Understanding Artifacts","text":"<p>After compilation, you'll find:</p> <pre><code>artifacts/\n\u251c\u2500\u2500 validators/\n\u2502   \u251c\u2500\u2500 protocol.plutus      # JSON format (for debugging)\n\u2502   \u2514\u2500\u2500 protocol.cbor         # Binary format (for deployment)\n\u2514\u2500\u2500 minting_policies/\n    \u251c\u2500\u2500 protocol_nfts.plutus\n    \u2514\u2500\u2500 protocol_nfts.cbor\n</code></pre> <ul> <li><code>.plutus</code> files: Human-readable JSON, useful for inspection</li> <li><code>.cbor</code> files: Compact binary format for on-chain deployment</li> </ul>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture Overview - Understand the system design</li> <li>Protocol Validator - Deep dive into validators</li> <li>Development Guide - Advanced development workflows</li> </ul>"},{"location":"getting-started/quickstart/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/quickstart/#build-failures","title":"Build Failures","text":"<p>If contracts fail to compile:</p> <ol> <li>Check Python version: <code>python --version</code> (should be 3.11 or 3.12)</li> <li>Verify OpShin installation: <code>uv run opshin --version</code></li> <li>Clean and rebuild: <code>rm -rf artifacts &amp;&amp; uv run python src/scripts/build_contracts.py</code></li> </ol>"},{"location":"getting-started/quickstart/#test-failures","title":"Test Failures","text":"<p>If tests fail:</p> <ol> <li>Ensure contracts are compiled: <code>uv run python src/scripts/build_contracts.py</code></li> <li>Check for missing dependencies: <code>uv sync --extra dev</code></li> <li>Clear cache: <code>rm -rf .pytest_cache .mypy_cache</code></li> </ol>"},{"location":"testing/overview/","title":"Testing Overview","text":"<p>Comprehensive testing strategy for Terrasacha Contracts.</p>"},{"location":"testing/overview/#testing-philosophy","title":"Testing Philosophy","text":"<p>Multi-layered testing approach:</p> <ol> <li>Unit Tests: Test individual functions in isolation</li> <li>Integration Tests: Test component interactions</li> <li>Contract Tests: Test compiled smart contracts</li> <li>Property Tests: Hypothesis-based testing for edge cases</li> </ol>"},{"location":"testing/overview/#test-markers","title":"Test Markers","text":"<p>Tests are organized using pytest markers:</p> <pre><code>@pytest.mark.unit\ndef test_datum_validation():\n    \"\"\"Fast unit test for datum validation logic\"\"\"\n    pass\n\n@pytest.mark.integration\ndef test_mint_and_update_flow():\n    \"\"\"Test integration between minting and validator\"\"\"\n    pass\n\n@pytest.mark.slow\ndef test_full_protocol_lifecycle():\n    \"\"\"Comprehensive test of entire protocol\"\"\"\n    pass\n\n@pytest.mark.contracts\ndef test_contract_compilation():\n    \"\"\"Verify contracts compile correctly\"\"\"\n    pass\n\n@pytest.mark.performance\ndef test_validator_performance():\n    \"\"\"Benchmark validator execution time\"\"\"\n    pass\n</code></pre>"},{"location":"testing/overview/#running-tests","title":"Running Tests","text":"<p>See: Running Tests</p>"},{"location":"testing/overview/#coming-soon","title":"Coming Soon","text":"<p>Detailed documentation for: - Writing effective tests - Mock utilities - Test fixtures - Coverage requirements - Performance benchmarking</p> <p>For now, see: - Source Code</p>"},{"location":"testing/running-tests/","title":"Running Tests","text":"<p>How to run tests in Terrasacha Contracts.</p>"},{"location":"testing/running-tests/#basic-usage","title":"Basic Usage","text":"<p>Run all tests: <pre><code>uv run pytest\n</code></pre></p> <p>Run with verbose output: <pre><code>uv run pytest -v\n</code></pre></p> <p>Run specific test file: <pre><code>uv run pytest tests/test_protocols.py\n</code></pre></p> <p>Run specific test function: <pre><code>uv run pytest tests/test_protocols.py::test_protocol_update\n</code></pre></p>"},{"location":"testing/running-tests/#test-selection","title":"Test Selection","text":""},{"location":"testing/running-tests/#by-marker","title":"By Marker","text":"<p>Run only unit tests: <pre><code>uv run pytest -m unit\n</code></pre></p> <p>Run only integration tests: <pre><code>uv run pytest -m integration\n</code></pre></p> <p>Exclude slow tests: <pre><code>uv run pytest -m \"not slow\"\n</code></pre></p> <p>Multiple markers: <pre><code>uv run pytest -m \"unit or integration\"\n</code></pre></p>"},{"location":"testing/running-tests/#by-keyword","title":"By Keyword","text":"<p>Run tests matching keyword: <pre><code>uv run pytest -k \"protocol\"\n</code></pre></p> <p>Exclude tests with keyword: <pre><code>uv run pytest -k \"not burn\"\n</code></pre></p>"},{"location":"testing/running-tests/#coverage-reports","title":"Coverage Reports","text":"<p>Run with coverage: <pre><code>uv run pytest --cov=src\n</code></pre></p> <p>Generate HTML coverage report: <pre><code>uv run pytest --cov=src --cov-report=html\n</code></pre></p> <p>View report: <pre><code>open htmlcov/index.html  # macOS\nxdg-open htmlcov/index.html  # Linux\n</code></pre></p> <p>Generate XML coverage (for CI): <pre><code>uv run pytest --cov=src --cov-report=xml\n</code></pre></p>"},{"location":"testing/running-tests/#parallel-execution","title":"Parallel Execution","text":"<p>Run tests in parallel (faster): <pre><code>uv run pytest -n auto\n</code></pre></p> <p>Specify number of workers: <pre><code>uv run pytest -n 4\n</code></pre></p>"},{"location":"testing/running-tests/#output-control","title":"Output Control","text":"<p>Stop on first failure: <pre><code>uv run pytest -x\n</code></pre></p> <p>Show local variables on failure: <pre><code>uv run pytest -l\n</code></pre></p> <p>Capture output (show print statements): <pre><code>uv run pytest -s\n</code></pre></p>"},{"location":"testing/running-tests/#test-discovery","title":"Test Discovery","text":"<p>List all tests without running: <pre><code>uv run pytest --collect-only\n</code></pre></p> <p>Show test names and markers: <pre><code>uv run pytest --markers\n</code></pre></p>"},{"location":"testing/running-tests/#performance-testing","title":"Performance Testing","text":"<p>Run performance benchmarks: <pre><code>uv run pytest -m performance --benchmark-only\n</code></pre></p> <p>Save benchmark results: <pre><code>uv run pytest --benchmark-save=baseline\n</code></pre></p> <p>Compare benchmarks: <pre><code>uv run pytest --benchmark-compare=baseline\n</code></pre></p>"},{"location":"testing/running-tests/#watch-mode","title":"Watch Mode","text":"<p>Auto-run tests on file changes: <pre><code>uv run pytest-watch\n</code></pre></p>"},{"location":"testing/running-tests/#common-workflows","title":"Common Workflows","text":""},{"location":"testing/running-tests/#quick-feedback-loop","title":"Quick Feedback Loop","text":"<p>For rapid development: <pre><code>uv run pytest -m \"not slow\" -x\n</code></pre></p>"},{"location":"testing/running-tests/#pre-commit-check","title":"Pre-Commit Check","text":"<p>Before committing: <pre><code>uv run pytest --cov=src --cov-report=term-missing\n</code></pre></p>"},{"location":"testing/running-tests/#full-ci-run","title":"Full CI Run","text":"<p>Complete test suite: <pre><code>uv run pytest --cov=src --cov-report=html --cov-report=xml -n auto\n</code></pre></p>"},{"location":"testing/running-tests/#troubleshooting","title":"Troubleshooting","text":""},{"location":"testing/running-tests/#clear-cache","title":"Clear Cache","text":"<p>If tests behave unexpectedly: <pre><code>rm -rf .pytest_cache\nuv run pytest --cache-clear\n</code></pre></p>"},{"location":"testing/running-tests/#rebuild-contracts","title":"Rebuild Contracts","text":"<p>If contract tests fail: <pre><code>uv run python src/scripts/build_contracts.py\nuv run pytest -m contracts\n</code></pre></p>"},{"location":"testing/running-tests/#verbose-debug","title":"Verbose Debug","text":"<p>Show maximum detail: <pre><code>uv run pytest -vv -s -l\n</code></pre></p>"},{"location":"testing/running-tests/#see-also","title":"See Also","text":"<ul> <li>Testing Overview</li> <li>Development Guide</li> </ul>"}]}