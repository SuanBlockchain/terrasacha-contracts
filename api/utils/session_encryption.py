"""
Session-Based Password Encryption Utilities

Provides secure encryption/decryption for wallet passwords stored in user sessions.
Uses AES-256 encryption via Fernet with session-key-based encryption.

This is separate from the wallet mnemonic encryption to enable auto-unlock:
- Wallet mnemonic: Encrypted with user's password (PBKDF2 + Fernet)
- Session password: Encrypted with session key (SHA256 + Fernet)

The session key is generated by the frontend and never stored on the backend
(only a hash is stored for verification).
"""

import base64
import hashlib
import secrets

from cryptography.fernet import Fernet


def generate_session_key() -> str:
    """
    Generate a cryptographically secure session key.

    This is used by the frontend to encrypt wallet passwords for auto-unlock.
    The frontend generates this key once and stores it securely.

    Returns:
        Base64-URL-safe encoded session key (32 bytes = 256 bits)

    Example:
        >>> session_key = generate_session_key()
        >>> # Store securely in frontend (encrypted local storage or memory)
    """
    return secrets.token_urlsafe(32)


def hash_session_key(session_key: str) -> str:
    """
    Hash a session key using SHA256.

    The hash is stored in the database for verification without storing
    the session key itself (defense in depth).

    Args:
        session_key: Base64-URL-safe session key from generate_session_key()

    Returns:
        Hexadecimal SHA256 hash of the session key

    Example:
        >>> session_key = "abc123..."
        >>> session_hash = hash_session_key(session_key)
        >>> # Store session_hash in database, NOT session_key
    """
    return hashlib.sha256(session_key.encode("utf-8")).hexdigest()


def _derive_key_from_session(session_key: str) -> bytes:
    """
    Derive a Fernet encryption key from a session key.

    Uses SHA256 to derive a 32-byte key suitable for Fernet encryption.
    This is simpler than PBKDF2 since session keys are already high-entropy.

    Args:
        session_key: Base64-URL-safe session key

    Returns:
        Base64-encoded 32-byte key suitable for Fernet

    Note:
        This is an internal utility function. Use encrypt_password_for_session()
        and decrypt_password_from_session() instead.
    """
    # Hash the session key to get a 32-byte key
    key_material = hashlib.sha256(session_key.encode("utf-8")).digest()

    # Fernet requires a base64-encoded 32-byte key
    return base64.urlsafe_b64encode(key_material)


def encrypt_password_for_session(password: str, session_key: str) -> str:
    """
    Encrypt a wallet password using a session key.

    This allows storing the wallet password encrypted in the database
    for auto-unlock functionality. The password can only be decrypted
    by providing the correct session key (which the frontend holds).

    Args:
        password: Wallet password to encrypt
        session_key: Session key from generate_session_key()

    Returns:
        Base64-encoded encrypted password

    Raises:
        ValueError: If password or session_key is empty

    Security:
        - Uses Fernet (AES-256 in CBC mode with HMAC authentication)
        - Session key is high-entropy (256 bits)
        - Authenticated encryption prevents tampering

    Example:
        >>> session_key = generate_session_key()
        >>> encrypted = encrypt_password_for_session("my_password", session_key)
        >>> # Store encrypted in UserSessionMongo
    """
    if not password or not password.strip():
        raise ValueError("Password cannot be empty")

    if not session_key or not session_key.strip():
        raise ValueError("Session key cannot be empty")

    # Derive Fernet key from session key
    encryption_key = _derive_key_from_session(session_key)

    # Create Fernet cipher
    cipher = Fernet(encryption_key)

    # Encrypt the password
    password_bytes = password.encode("utf-8")
    encrypted_bytes = cipher.encrypt(password_bytes)

    # Return as base64-encoded string
    return encrypted_bytes.decode("utf-8")


def decrypt_password_from_session(encrypted_password: str, session_key: str) -> str:
    """
    Decrypt a wallet password using a session key.

    Reverses the encryption performed by encrypt_password_for_session().
    Used during auto-unlock to retrieve the wallet password.

    Args:
        encrypted_password: Base64-encoded encrypted password
        session_key: Session key that was used for encryption

    Returns:
        Decrypted wallet password (plaintext)

    Raises:
        ValueError: If any parameter is empty or decryption fails
        cryptography.fernet.InvalidToken: If session key is wrong

    Security:
        - Fernet provides authenticated encryption
        - Wrong session key will raise InvalidToken
        - Prevents tampering with encrypted data

    Example:
        >>> password = decrypt_password_from_session(encrypted, session_key)
        >>> # Use password to unlock wallet
        >>> del password  # Clear from memory after use
    """
    if not encrypted_password or not encrypted_password.strip():
        raise ValueError("Encrypted password cannot be empty")

    if not session_key or not session_key.strip():
        raise ValueError("Session key cannot be empty")

    try:
        # Derive the same encryption key from session key
        encryption_key = _derive_key_from_session(session_key)

        # Create Fernet cipher
        cipher = Fernet(encryption_key)

        # Decrypt the password
        encrypted_bytes = encrypted_password.encode("utf-8")
        decrypted_bytes = cipher.decrypt(encrypted_bytes)

        # Return as string
        return decrypted_bytes.decode("utf-8")

    except Exception as e:
        # Re-raise with more helpful message
        if "Invalid" in str(e) or "token" in str(e).lower():
            raise ValueError("Invalid session key or corrupted data") from e
        raise
